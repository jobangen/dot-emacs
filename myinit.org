#+STARTUP: content
* Grundeinstellungen
** defalias
#+begin_src emacs-lisp
(defalias 'sc 'shell-command-to-string)
#+end_src

** Einst
#+BEGIN_SRC emacs-lisp
(setq split-width-threshold 110)
(setq inhibit-splash-screen t) ;;Remove splash screen
(desktop-save-mode 1) ;; Erinnert die zuletzt geöffneten Dateien
(fset 'yes-or-no-p 'y-or-n-p)
(setq large-file-warning-threshold nil)
(setq sentence-end-double-space nil)

(transient-mark-mode nil) ;; No region when it is not highlighted
(global-font-lock-mode 1) ;;syntax highlighting everywhere
(global-visual-line-mode 1) ;;Add proper word wrapping
(global-auto-revert-mode t) ;;aktualisiert buffer automatisch
(setq auto-revert-interval 2) ;; Prüfinterval in Sek.
(setq auto-revert-verbose nil)
(set-language-environment "UTF-8")
(set-terminal-coding-system 'utf-8) ;;UTF 8 by default
(set-keyboard-coding-system 'utf-8) ;;(prefer-coding-system 'utf-8)
(setq-default indent-tabs-mode nil ;; Insert tabs as spaces (not tabs)
	          indicate-buffer-boundaries 'left	;; Graphical gimmick
	          indicate-empty-lines t	;; Graphical gimmick
)
(setq next-line-add-newlines t) ;; C-n erzeugt Absatz am Ender der Zeile

;; Save whatever’s in the current (system) clipboard before
;; replacing it with the Emacs’ text.
;; https://github.com/dakrone/eos/blob/master/eos.org
(setq save-interprogram-paste-before-kill t)

;; (add-hook 'text-mode-hook (lambda () (variable-pitch-mode t)))
(dolist (hook '(LaTeX-mode-hook
                ))
  (add-hook hook (lambda () (variable-pitch-mode t))))

(setq time-stamp-active t
      time-stamp-format "%04y-%02m-%02d %02H:%02M:%02S")
(setq time-stamp-start "#\\+DATE:[ \t]+\\\\?[\[\"<]+")
(setq time-stamp-end "\\\\?[\]\">]")
(add-hook 'write-file-hooks 'time-stamp)
#+END_SRC

** server
#+begin_src emacs-lisp
;; define function to shutdown emacs server instance
(defun server-shutdown ()
  "Save buffers, Quit, and Shutdown (kill) server"
  (interactive)
  (save-some-buffers)
  (kill-emacs)
  )
#+end_src

** dir-setup
#+begin_src emacs-lisp
(defvar db-dir
   (expand-file-name "~/Dropbox/db/"))

(setq org-directory "~/Dropbox/db/org/")

(defvar zettelkasten-dir
   (expand-file-name (concat db-dir "zk/")))

(defvar texte-dir
   (expand-file-name "~/texte/"))

(defvar backup-dir
   (expand-file-name (concat user-emacs-directory "backups/")))

(defvar autosave-dir
   (expand-file-name (concat user-emacs-directory "autosave/")))

(defvar job/bibliography-file
   (expand-file-name (concat db-dir "biblio.bib")))

(defvar custom-temp
   (expand-file-name "~/.custom-temp/"))
#+end_src

** Backups
#+begin_src emacs-lisp
(setq backup-directory-alist
      `(("." . ,backup-dir)))
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-list-file-prefix autosave-dir)
(setq auto-save-file-name-transforms
      `((".*" ,autosave-dir t)))
#+end_src

** Archive und Packages
#+begin_src emacs-lisp
(require 'package)
(setq package-archives '(("gnu"       . "https://elpa.gnu.org/packages/")
                         ("melpa"     . "https://melpa.milkbox.net/packages/")
                         ("org"       . "http://orgmode.org/elpa/")))
#+end_src

* use-package, bind-key
#+begin_src emacs-lisp
;; Load use-package, used for loading packages everywhere else
(setq use-package-enable-imenu-support t)
(require 'use-package nil t)
;; Set to t to debug package loading or nil to disable
(setq use-package-verbose t)

(use-package bind-key
  :ensure t)
#+end_src

* Sicherheit
** gpg
#+begin_src emacs-lisp
(setq epg-gpg-program "gpg2")

;; fragt in emacs nach pw; braucht "allow-loopback-pinentry" in gpg-agent.conf
(setq epa-pinentry-mode 'loopback)
#+end_src
** sensitivemode
#+begin_src emacs-lisp
;; sensitive mode wird eingeschaltet, wenn gpg-files bearbeitet werden
(setq auto-mode-alist
 (append '(("\\.gpg$" . sensitive-mode))
               auto-mode-alist))
;; Disabling Backup and Auto-save in Emacs
(define-minor-mode sensitive-mode
  "For sensitive files like password lists.
It disables backup creation and auto saving.

With no argument, this command toggles the mode.
Non-null prefix argument turns on the mode.
Null prefix argument turns off the mode."
  ;; The initial value.
  nil
  ;; The indicator for the mode line.
  " Sensitive"
  ;; The minor mode bindings.
  nil
  (if (symbol-value sensitive-mode)
      (progn
	;; disable backups
	(set (make-local-variable 'backup-inhibited) t)
	;; disable auto-save
	(if auto-save-default
	    (auto-save-mode -1)))
    ;resort to default value of backup-inhibited
    (kill-local-variable 'backup-inhibited)
    ;resort to default auto save setting
    (if auto-save-default
	(auto-save-mode 1))))
#+end_src

* Appearance
tool-bar-mode
menu-bar-mode
müssen manuell deaktiviert werden
** bar-modes
#+begin_src emacs-lisp
(if (window-system)
      (tooltip-mode -1)
      (tool-bar-mode -1)
      (menu-bar-mode -1)
      (scroll-bar-mode -1)
      (set-fringe-mode '(1 . 1)))
#+end_src

** Font
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(font . "Inconsolata-12"))
#+end_src

** Themes
#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path (concat user-emacs-directory "themes"))
(load-theme 'greylines t)
;;(load-theme 'leuven t)
#+end_src

** smart-mode-line
#+begin_src emacs-lisp
(use-package smart-mode-line
  :ensure t
  :init
   (setq sml/theme 'dark)
   (sml/setup)
   (setq sml/shorten-directory t)
   (setq sml/shorten-modes t)
   (setq sml/name-width 25)
   (setq sml/mode-width 'full)
   (add-to-list 'sml/replacer-regexp-list '("^:DB:diss/" ":ds:") t)
   (add-to-list 'sml/replacer-regexp-list '("^:ds:tex/" ":ds:tx:") t)
   (add-to-list 'sml/replacer-regexp-list '("^:ds:tx:parts/" ":ds:tx:p:") t)
   (add-to-list 'sml/replacer-regexp-list '("^:ds:tx:p:part1/" ":ds:") t)
   (add-to-list 'sml/replacer-regexp-list '("^~/Dokumente/" ":Dok:") t)
   (add-to-list 'sml/replacer-regexp-list '("^~/archiv/" ":arch:") t)
   (add-to-list 'sml/replacer-regexp-list '("^~/Downloads/" ":DL:") t)
   (add-to-list 'sml/replacer-regexp-list '("^~/texte/" ":TXT:") t)
)
#+end_src

** volatile-highlights
#+begin_src emacs-lisp
(use-package volatile-highlights
  :diminish volatile-highlights-mode
  :config
   (volatile-highlights-mode t))
#+end_src

** visual-fill-column
#+begin_src emacs-lisp
(use-package visual-fill-column
  :ensure t
  :defer t
  :config (setq-default visual-fill-column-center-text t
                        visual-fill-column-fringes-outside-margins t))
#+end_src

* Bedienung & Interface
** kbd
[[http://pragmaticemacs.com/emacs/use-your-digits-and-a-personal-key-map-for-super-shortcuts/][Use your digits and a personal key map for super shortcuts]]
#+begin_src emacs-lisp
  ;; unset C- and M- digit keys
  (dotimes (n 10)
    (global-unset-key (kbd (format "C-%d" n)))
    (global-unset-key (kbd (format "M-%d" n))))

  (define-prefix-command 'job-map)
  (global-set-key (kbd "C-1") 'job-map)
#+end_src

#+begin_src emacs-lisp
  (bind-key "<menu>" 'switch-to-buffer)
  (bind-key "C-h" 'backward-delete-char)
  (bind-key "C-x C-k" 'kill-region)
  ;;(bind-key "C-r" 'previous-line)
  (bind-key "C-ö ö" 'save-some-buffers)
  (bind-key "C-?" 'help-command)
  (bind-key "C-x C-b" 'ibuffer)
  (bind-key "M-SPC" 'cycle-spacing)

  (global-set-key (kbd "<return>") 'ignore)
  (global-set-key (kbd "<backspace>") 'ignore)
  (global-set-key (kbd "C-ö") ctl-x-map)
  (define-key key-translation-map (kbd "C-ä") (kbd "C-c"))
#+end_src

** cursor
#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure t
  :diminish multiple-cursors
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C-S-ä C-S-ä" . mc/edit-lines)
         ("C-<" . mc/mark-next-like-this)
         ("C-c C-<" . mc/mark-all-like-this)))
#+end_src

** scrollen
http://zeekat.nl/articles/making-emacs-work-for-me.html
#+begin_src emacs-lisp
(setq redisplay-dont-pause t
      scroll-margin 3
      scroll-step 1
      scroll-conservatively 10000
      scroll-preserve-screen-position 1)

(setq mouse-wheel-follow-mouse 't)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))

(global-set-key (kbd "M-n") (kbd "C-u 1 C-v"))
(global-set-key (kbd "M-p") (kbd "C-u 1 M-v"))
#+end_src

** show keystrokes
#+begin_src emacs-lisp
;; Show unfinished keystrokes early.
(setq echo-keystrokes 0.1)
#+end_src

** char-menu
#+begin_src emacs-lisp
(use-package char-menu
 :ensure t
;;  :bind ("H-s" . char-menu)
 :config 
  (setq char-menu '("–" "—" "„“" "‘’" "“”" "»«" "…"
                            ("Typography" "•" "©" "†" "‡" "°" "·" "§" "№" "★")
                            ("Math"       "≈" "≡" "≠" "∞" "×" "±" "∓" "÷" "√" "⊂" "⊃")
                            ("Arrows"     "←" "→" "↑" "↓" "⇐" "⇒" "⇑" "⇓")
                            ("Greek"      "α" "β" "Y" "δ" "ε" "ζ" "η" "θ" "ι" "κ" "λ" "μ" "ν" "ξ" "ο" "π" "ρ" "σ" "τ" "υ" "φ" "χ" "ψ" "ω")
                            ("Other Languages" "Œ"))))
#+end_src

** key-chord
#+begin_src emacs-lisp
(use-package key-chord
  :config
  (progn
    (setq key-chord-two-keys-delay 0.15)
    (setq key-chord-one-key-delay 0.25)
    (key-chord-mode 1)
    (key-chord-define-global "jk" 'avy-goto-char-timer)
    (key-chord-define-global "jl" 'avy-goto-line)
    (key-chord-define-global "jf" 'ace-window)))
#+end_src

** ace-window
#+begin_src emacs-lisp
(use-package ace-window
 :bind ("C-c k" . ace-delete-window)
 :config
  (progn
   (setq aw-scope 'frame)
   (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
   (setq aw-dispatch-always nil))
)
#+end_src

** isearch
#+begin_src emacs-lisp
(bind-key  "M-i" 'swiper-from-isearch isearch-mode-map)
#+end_src

** ivy
#+begin_src emacs-lisp
(use-package ivy
  :ensure t
  :diminish ivy-mode
  :bind (("C-c C-r" . ivy-resume)
         :map ivy-mode-map
           ("C-h" . backward-delete-char)
         :map ivy-minibuffer-map
           ("C-h" . backward-delete-char)
           ("C-w" . backward-kill-word)
        )
  :config
     (require 'ivy-hydra)
     (ivy-mode 1)
     (setq ivy-height 13)
;;     (setq ivy-fixed-height-minibuffer t)
     (setq ivy-count-format "(%d/%d) ")
     (setq ivy-initial-inputs-alist nil)
     (setq ivy-wrap t)
     (setq ivy-use-virtual-buffers t)
     (setq ivy-display-style 'fancy)
;;     (setq ivy-re-builders-alist
;;               '((counsel-ag . ivy--regex-ignore-order)
;;                 (t . ivy--regex-plus)))

     (defun ora-insert (x)
       (insert
        (if (stringp x)
            x
          (car x))))

     (defun ora-kill-new (x)
       (kill-new
        (if (stringp x)
            x
          (car x))))

     (ivy-set-actions
      t
      '(("i" ora-insert "insert")
        ("w" ora-kill-new "copy")))

     (setq ivy-switch-buffer-faces-alist
           '((emacs-lisp-mode . swiper-match-face-1)
             (dired-mode . ivy-subdir)
             (org-mode . org-level-4)))

     (setq ivy-views
           '((",todo"
              (horz
                (buffer "*pomidor*")
                (buffer "*Org Agenda*")))
             (",mail"
              (horz
                (buffer "*Group*")
                (buffer "*OfflineIMAP*")))
             (",zettelkasten"
              (horz
               (file "~/Dropbox/db/zk/")
               (file "~/Dropbox/db/zk/")))))
)
#+end_src

** swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :bind (:map ivy-minibuffer-map
         ("C-#" . zettelkasten-insert-regex)))
#+END_SRC

** counsel
#+begin_src emacs-lisp
(use-package counsel
  :ensure t
  :bind (("C-s" . counsel-grep-or-swiper)
         ("C-S-s" . counsel-imenu)
         ("C-S-i" . counsel-grep-or-swiper)
         ("C-c u" . counsel-linux-app)
         ("C-ä u" . counsel-linux-app)
         ("C-M-s" . counsel-ag)
         ("C-x l" . counsel-locate)
         ("C-ö l" . counsel-locate)
         ("M-y" . counsel-yank-pop)
         ("M-ü" . counsel-yank-pop)
         :map ivy-minibuffer-map
          ("M-y" . ivy-next-line)
          ("M-ü" . ivy-next-line))
)
  #+end_src

** smex
#+BEGIN_SRC emacs-lisp
(use-package smex
    :load-path "~/.emacs.d/non-elpa/smex-abo-abo"
    :bind (("M-x" . smex)
           ("C-x C-m" . smex)
           ("M-ö" . smex)
           ("M-X" . smex-major-mode-commands)
           ("M-Ö" . smex-major-mode-commands)
           ("C-c C-c M-x" . execute-extended-command))
    :init
     (require 'smex)
     (setq smex-completion-method 'ivy)
     (smex-initialize)
)
#+END_SRC

** which-key
#+begin_src emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :config
   (which-key-mode))
#+end_src

** avy
#+begin_src emacs-lisp
(use-package avy
  :ensure t
  :bind (("M-s" . avy-goto-char-timer)
         ("H-i" . avy-goto-char-timer))
  :config
   (progn
    (setq avy-all-windows t)
    (setq avy-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l ?ö))

    (define-key input-decode-map (kbd "C-i") (kbd "H-i"))))
#+end_src

** zzz-to-char
#+begin_src emacs-lisp
(use-package zzz-to-char
  :bind ("C-z" . zzz-to-char)
  :config
    (setq zzz-to-char-reach 6))
#+end_src

** imenu
#+begin_src emacs-lisp
(setq org-imenu-depth 9)

(use-package imenu-anywhere
;;  :bind ("C-S-s" . ivy-imenu-anywhere)
)
#+end_src

** shell
#+begin_src emacs-lisp
(setq comint-password-prompt-regexp
      (concat comint-password-prompt-regexp
              "\\|^.*Passwort für.*:\\s *\\'"))
#+end_src

** eshell
#+begin_src emacs-lisp
(bind-key "C-c j" 'eshell)

(setq eshell-visual-commands
'("less" "tmux" "htop" "top" "bash" "zsh" "fish" "watch" "time" "sudo"))
#+end_src

** winner-mode
#+begin_src emacs-lisp
  (use-package winner
    :init
     (winner-mode))
#+end_src

** expand-region
#+begin_src emacs-lisp
(use-package expand-region
  :bind (("C-c m" . er/expand-region)))
#+end_src

* org-mode
** allgemein
#+begin_src emacs-lisp
(use-package org
  :ensure t
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         ("C-c ä" . org-capture)
         ("<f11>" . org-clock-in)
         ("C-c i" . org-clock-in)
        )
  :config
   (progn
     ;;Pfade
     (setq org-default-notes-file "inbox.org"
           org-agenda-diary-file "journal.org"
           org-agenda-include-diary nil)

     ;; shift-select
     (setq org-support-shift-select 'always)
     ;;keine automatischen Leerzeilen vor Entries
     (setq org-blank-before-new-entry nil) 
     ;; follow links by pressing ENTER on them
     (setq org-return-follows-link t)
     ;; syntax highlight code in source blocks
     (setq org-src-fontify-natively t)
     ;; Don't allow editing of folded regions
     (setq org-catch-invisible-edits 'error)

     (add-hook 'org-agenda-mode-hook
       (lambda ()
         (bind-key "<f11>" 'org-agenda-clock-in org-agenda-mode-map)))
   )
)
   

(use-package org-plus-contrib
  :ensure t
  :defer t)

(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))

;; 18.23 Highlight clock when running overtime ;; in theme!!!
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(default ((t (:family "Ubuntu Mono" :foundry "unknown" :slant normal :weight normal :height 113 :width normal))))
 '(org-mode-line-clock ((t (:foreground "red" :box (:line-width -1 :style released-button)))) t))
#+end_src

** shortcuts for major org-files
[[https://github.com/baron42bba/.emacs.d/blob/master/bba.org#define-some-shortcuts-to-access-major-org-files][Define some shortcuts to access major org files.]]
#+begin_src emacs-lisp
(bind-key "C-c 0" '(lambda () (interactive) (find-file (concat user-emacs-directory "myinit.org"))))
(bind-key "C-c 1" '(lambda () (interactive) (find-file "~/Dropbox/db/org/journal.org")))
(bind-key "C-c 2" '(lambda () (interactive) (find-file "~/Dropbox/db/org/wiss.org")))
(bind-key "C-c 3" '(lambda () (interactive) (find-file "~/Dropbox/db/org/pers.org")))
(bind-key "C-c 4" '(lambda () (interactive) (find-file "~/Dropbox/db/org/irw.org")))
(bind-key "C-c 9" '(lambda () (interactive) (find-file "~/Dropbox/db/zk")))


#+end_src

** agenda
#+begin_src emacs-lisp
;; Aktuelle Zeile in der Agenda hervorheben
(add-hook 'org-agenda-mode-hook '(lambda () (hl-line-mode 1 ))) ;; lieber ins theme?

;;(setq org-agenda-dim-blocked-tasks t)
(setq org-agenda-dim-blocked-tasks nil) ;; soll schneller sein
(setq org-agenda-skip-scheduled-if-deadline-is-shown 'not-today)
(setq org-agenda-start-on-weekday nil)

(setq org-agenda-inhibit-startup t)
(setq org-agenda-use-tag-inheritance nil)

(setq org-agenda-ignore-drawer-properties '(category))

(setq org-stuck-projects
           '("+TODO={PROJ}" ("NEXT" "STARTED") ("longterm")))

(add-hook 'org-agenda-mode-hook
   (lambda ()
      (bind-key "C-c i" 'org-agenda-clock-in org-agenda-mode-map)))

#+end_src

*** agenda-commands
#+begin_src emacs-lisp
;; Custom agenda command definitions
(setq org-agenda-custom-commands
 '(
	(" " "Custom-Agenda"
           ((agenda ""
                  ((org-agenda-span 1)
		         (org-agenda-remove-tags t)
                   (org-agenda-show-all-dates t)))
		  (tags "INBOX"
			((org-agenda-overriding-header "Inbox:")
			 (org-agenda-remove-tags t)))
		  (todo "PROJ|TODO"
                  ((org-agenda-overriding-header "Projects & Tasks:")
			 (org-agenda-remove-tags t)
                   (org-tags-match-list-sublevels 'indented)
			 (org-agenda-skip-function  
                    '(org-agenda-skip-entry-if 'deadline 'scheduled))
                   (org-agenda-skip-function
                    '(org-agenda-skip-subtree-if 
                      'regexp ":txt:"))
                   (org-agenda-sorting-strategy
                    '( category-keep))
                   (org-agenda-prefix-format "%l")))
            (todo "WAITING"
			((org-agenda-overriding-header "Waiting Tasks:")
			 (org-agenda-remove-tags t)))
            (todo "HOLD"
			((org-agenda-overriding-header "Postponed Tasks:")
			 (org-agenda-remove-tags t)))))
  ("t" "Today"
           ((tags-todo "today"
                 ((org-agenda-overriding-header "Today's Tasks:")
                  (org-agenda-remove-tags t)))
            (todo "STARTED"
                  ((org-agenda-overriding-header "Started:")
         	         (org-agenda-remove-tags t)
                   (org-agenda-skip-function
                    '(org-agenda-skip-subtree-if
                      'regexp ":today:"))))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Tasks:")
         	         (org-agenda-remove-tags t)))))
  ("d" "Dissertation"
           ((tags-todo "diss"
			((org-agenda-overriding-header "Dissertation")
			 (org-agenda-remove-tags t)
			 (org-tags-match-list-sublevels 'indented)
			 (org-agenda-sorting-strategy
                             '(category-up))))))
  ("l" "Literatur"
           ((tags-todo "literature"
			((org-agenda-overriding-header "Texts & Tasks")
			 (org-agenda-remove-tags t)
			 (org-tags-match-list-sublevels 'indented)
			 (org-agenda-sorting-strategy
                             '(category-up))))))
	("p" "Produktion"
	         ((tags-todo "produktion"
			((org-agenda-overriding-header "Projekte:")
			 (org-agenda-remove-tags t)
			 (org-tags-match-list-sublevels 'indented)
			 (org-agenda-sorting-strategy
                             '(category-keep))))
            (todo "ENTWURF"
			((org-agenda-overriding-header "Entwürfe:")
			 (org-agenda-remove-tags t)))
   	  (todo "IDEE"
			((org-agenda-overriding-header "Ideen:")
			 (org-agenda-remove-tags t)))))
	("k" "Kalender & Termine"
        	 ((agenda "" 
               ((org-agenda-span 96)
		      (org-agenda-show-all-dates t)
		      (org-agenda-skip-function 
                 '(org-agenda-skip-entry-if 'deadline 'scheduled))))))
	("c" "Clean up"
           ((tags-todo "/WAITING"
		     ((org-agenda-overriding-header "Waiting but unscheduled:")
		      (org-agenda-skip-function  '(org-agenda-skip-entry-if 'deadline 'scheduled))
		      (org-agenda-remove-tags t)))
	        (todo "DONE"
			((org-agenda-overriding-header "Tasks to Archive:")
			 (org-agenda-remove-tags t)))))))
#+end_src

*** agenda-hydra
#+begin_src emacs-lisp
  (add-hook 'org-agenda-mode-hook
     (lambda ()
        (bind-key "v" 'hydra-org-agenda-view/body org-agenda-mode-map)))

(defun org-agenda-cts ()
  (let ((args (get-text-property
               (min (1- (point-max)) (point))
               'org-last-args)))
    (nth 2 args)))

(defhydra hydra-org-agenda-view (:hint none)
  "
_d_: ?d? day        _g_: time grid=?g? _a_: arch-trees
_w_: ?w? week       _[_: inactive      _A_: arch-files
_t_: ?t? fortnight  _f_: follow=?f?    _r_: report=?r?
_m_: ?m? month      _e_: entry =?e?    _D_: diary=?D?
_y_: ?y? year       _q_: quit          _L__l__c_: ?l?"
  ("SPC" org-agenda-reset-view)
  ("d" org-agenda-day-view
       (if (eq 'day (org-agenda-cts))
           "[x]" "[ ]"))
  ("w" org-agenda-week-view
       (if (eq 'week (org-agenda-cts))
           "[x]" "[ ]"))
  ("t" org-agenda-fortnight-view
       (if (eq 'fortnight (org-agenda-cts))
           "[x]" "[ ]"))
  ("m" org-agenda-month-view
       (if (eq 'month (org-agenda-cts)) "[x]" "[ ]"))
  ("y" org-agenda-year-view
       (if (eq 'year (org-agenda-cts)) "[x]" "[ ]"))
  ("l" org-agenda-log-mode
       (format "% -3S" org-agenda-show-log))
  ("L" (org-agenda-log-mode '(4)))
  ("c" (org-agenda-log-mode 'clockcheck))
  ("f" org-agenda-follow-mode
       (format "% -3S" org-agenda-follow-mode))
  ("a" org-agenda-archives-mode)
  ("A" (org-agenda-archives-mode 'files))
  ("r" org-agenda-clockreport-mode
       (format "% -3S" org-agenda-clockreport-mode))
  ("e" org-agenda-entry-text-mode
       (format "% -3S" org-agenda-entry-text-mode))
  ("g" org-agenda-toggle-time-grid
       (format "% -3S" org-agenda-use-time-grid))
  ("D" org-agenda-toggle-diary
       (format "% -3S" org-agenda-include-diary))
  ("!" org-agenda-toggle-deadlines)
  ("["
   (let ((org-agenda-include-inactive-timestamps t))
     (org-agenda-check-type t 'timeline 'agenda)
     (org-agenda-redo)))
  ("q" (message "Abort") :exit t))
#+end_src

** appearance
#+begin_src emacs-lisp
(use-package org-indent
;;  :commands org-indent-mode
  :diminish org-indent-mode
  :init
  (progn
   (setq org-startup-indented t))
)

(setq org-hide-leading-stars t)
(setq org-startup-folded nil)
(setq org-ellipsis "…")

(add-to-list 'auto-mode-alist '("\\.txt\\'" . org-mode))
#+end_src

** behaviour
#+begin_src emacs-lisp
;; autolist
(use-package org-autolist
  :commands org-autolist-mode
  :diminish org-autolist-mode
  :init
  (progn
    (add-hook 'org-mode-hook (lambda () (org-autolist-mode)))
  ))
#+end_src

** speedkeys
#+begin_src emacs-lisp
(setq org-use-speed-commands t)
(setq org-speed-commands-user
'(("S" . (widen))))
#+end_src

** habits
#+begin_src emacs-lisp
(require 'org-habit)

(setq org-habit-graph-column 36)
(setq org-habit-preceding-days 31)
(setq org-habit-following-days 7)
(setq org-habit-show-habits-only-for-today t)
#+end_src

** Prioritäten
#+begin_src emacs-lisp
(setq org-highest-priority ?A)
(setq org-default-priority ?D)
(setq org-lowest-priority ?E)
#+end_src

** todo-states und -tags
#+begin_src emacs-lisp
  ;; Ein "!" bedeutet Zeitstempel
  ;; Ein "@" bedeutet Notiz
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n!)" "STARTED(s!)" "|" "DONE(d)")
                (sequence "APPT(a)" "PROJ(p)" "WAITING(w@/!)" "HOLD(h@/!)" "|"  "DELEGATED(D@/!)" "CANCELLED(c@/!)")
                (sequence "|" "IDEE(i)" "ENTWURF(e)"))))

  (setq org-clock-in-switch-to-state 'bh/clock-in-to-next)

  (defun bh/clock-in-to-next (kw)
    "Switch a task from TODO to STARTED when clocking in.
  Skips capture tasks, projects, and subprojects.
  Switch projects and subprojects from STARTED back to TODO"
    (when (not (and (boundp 'org-capture-mode) org-capture-mode))
      (cond
       ((and (member (org-get-todo-state) (list "TODO"  "DONE" "WAITING" "HOLD" "DELEGATED" "CANCELLED"))
             (bh/is-task-p))
        "STARTED")
       ((and (member (org-get-todo-state) (list "STARTED"))
             (bh/is-project-p))
        "TODO"))))

  (setq org-todo-state-tags-triggers
        (quote ((done ("today"))
                ("WAITING" ("today"))
                ("HOLD" ("today"))
                ("TODO" ("today")))))


  ;; Formatierung für TODO-tags
  (setq org-todo-keyword-faces ;; in theme!
        (quote (("PROJ" :foreground "dark red" :weight semi-bold)
                ("NEXT" :foreground "blue" :weight semi-bold)
                ("STARTED" :foreground "blue" :weight semi-bold)
                ("WAITING" :foreground "orange" :weight semi-bold)
                ("HOLD" :foreground "magenta" :weight semi-bold))))
#+end_src

** capture-functions
#+begin_src emacs-lisp
(defun capture-report-date-file (path)
  (let
   ((id      (read-string "ID: "))
    (name    (read-string "Name: ")))
   (expand-file-name (concat path id name ".txt"))))

;;http://stackoverflow.com/questions/24967910/org-mode-capture
(defun org-capture-berlinantiquariat ()
  "Capture a class template for org-capture."
    (let ((date        (org-read-date))
          (time-begin  (read-string "Begin: " nil nil '(nil)))
          (time-end    (read-string "End: " nil nil '(nil)))
          (length      (read-string "Length: " nil nil '(nil))))
      (when (and date)
        (concat (format "* BerlinAntiquariat   :work:\n")
                (format ":PROPERTIES:\n")
                (format ":CATEGORY: work\n")
                (format ":TYPE:     work\n")
                (format ":WORK:     berlinantiquariat\n")
                (format ":DATE:     [%s]\n" date)
                (format ":TIME:     %s--%s\n" time-begin time-end)
                (format ":LENGTH:   %s\n" length)
                (format ":END:\n")
                (format ":CLOCK:\n")
                (format "CLOCK: [%s %s]--" date time-begin)
                (format "[%s %s] =>\n" date time-end)
                (format ":END:")
))))

(defun org-capture-wiss ()
  "Capture a class template for org-capture."
    (let ((date        (org-read-date))
          (name        (completing-read "Veranstaltung: "
                         '((""                                1)
                           ("Knoblauch: Forschungswerkstatt"  2)
                           ("Wissenschaftskommunikation    "  3)
                           ("Topoi: Lesezirkel"               4)
                           ("Forschungswerkstatt FU"          5)
                          )  nil t ""))
          (time-begin  (read-string "Begin: " nil nil '(nil)))
          (time-end    (read-string "End: " nil nil '(nil))))
      (when (and date)
        (concat (format "* %s      :wiss:\n" name)
                (format ":PROPERTIES:\n")
                (format ":CATEGORY: wiss\n")
                (format ":END:\n")
                (format ":CLOCK:\n")
                (format "CLOCK: [%s %s]--" date time-begin)
                (format "[%s %s] => %%?\n" date time-end)
                (format ":END:")
))))
#+end_src

** capture
#+begin_src emacs-lisp
(setq org-capture-templates '(

("a" "Appointment" entry (file "calender.org")
 "* %^{Description}
<%(org-read-date)%?>
\n")

("c" "Contact" entry (file (lambda () (expand-file-name (concat db-dir "contacts.org"))))
 "* %(org-contacts-template-name)
:PROPERTIES:
:EMAIL: %(org-contacts-template-email)
:END:"
)

("t" "todo" entry (file "inbox.org")
 "* TODO %^{Task} %^G
SCHEDULED: %t
:PROPERTIES:
:CREATED:   %U
:CATEGORY:  %^{Category|wiss|work|pers}
:EFFORT: %^{Effort|0:10|0:15|0:20|0:30|0:45|1:00|1:30|2:00|3:00|4:00|5:00|6:00|7:00|8:00}
:END:
%?")

("T" "todo at point" entry (clock)
 "* TODO %^{Task}
SCHEDULED: %t
:PROPERTIES:
:CREATED: %U
:CATEGORY:  %^{Category|wiss|work|pers}
:EFFORT: %^{Effort|0:10|0:15|0:20|0:30|0:45|1:00|1:30|2:00|3:00|4:00|5:00|6:00|7:00|8:00}
:END:
%?\n")

("n" "note" entry (file+headline "inbox.org" "Notes")
 "* %^{Note}
:PROPERTIES:
:CREATED: %U
:END:
 %?")

("i" "interruption" entry (file "inbox.org")
 "%^{Task}
:PROPERTIES:
:CREATED: %U
:CATEGORY:  %^{Category|wiss|work|pers}
:END:
%?" :clock-in t :clock-resume t)

("p" "push" plain (clock)
 "- %U: [[%l]%?]")

("j" "Journal")
("jj" "Journal" entry (file+datetree+prompt "journal.org")
 "* %^{Headline}  :journal:
%T%?
:PROPERTIES:
:CREATED: [%<%Y-%m-%d %a %H:%M>]
:CATEGORY:  %^{Category|wiss|work|pers}
:END:
")

("jt" "Journal todo" entry (file+datetree "journal.org")
"* TODO %^{Task} :today:
SCHEDULED: %t
:PROPERTIES:
:CREATED: %U
:CATEGORY:  pers
:EFFORT: %^{Effort|0:10|0:15|0:20|0:30|0:45|1:00|1:30|2:00|3:00|4:00|5:00|6:00|7:00|8:00}
:END:
%?")

("jl" "Literaturbearbeitung" entry (file+datetree "journal.org")
 "* Literaturbearbeitung
:PROPERTIES:
:CATEGORY: wiss
:END:" :immediate-finish t :jump-to-captured t)

("jm" "Mailbearbeitung" entry (file+datetree "journal.org")
 "* Mailbearbeitung
:PROPERTIES:
:CATEGORY: wiss
:END:" :jump-to-captured t :immediate-finish t)

("jb" "BerlinAntiquariat" entry (file+datetree+prompt "journal.org")
 #'org-capture-berlinantiquariat :jump-to-captured t)

("je" "Electricity" plain (file (lambda () (expand-file-name (concat db-dir "plot/electricity.csv"))))
"%(org-read-date); %?")

("jw" "Wissenschaft" entry (file+datetree+prompt "journal.org")
 #'org-capture-wiss :jump-to-captured t)

("m" "mail todo" entry (file+headline "inbox.org" "Mail")
 "* TODO %^{Task}
SCHEDULED: %t
:PROPERTIES:
:CREATED: %U
:CATEGORY:  %^{Category|wiss|work|pers}
:END:
%:fromname wrote on %:date-timestamp-inactive:
Subject: [[%l][%:subject]]
#+BEGIN_QUOTE
%i
#+END_QUOTE")

("b" "bibtex" plain (file (lambda () (expand-file-name job/bibliography-file)))
"%?" :jump-to-captured t :empty-lines 1)

("l" "Literatur" entry (file+headline "inbox.org" "Literatur")
 "* TODO %^{Author & Titel} :txt:
:PROPERTIES:
:CREATED:   %U
:CATEGORY:  wiss
:BIBL:      %^{Bibl|ub|sozbib|cba|cbn|fmi}
:SIGNATURE: %^{Signatur}
:SOURCE:    %?
:END:")

("P" "Projekt" entry (file "inbox.org")
"* PROJ %^{Projekt}
:PROPERTIES:
:CREATED: %U
:CATEGORY:  %^{Category|wiss|work|pers}
:END:")

("g" "Geld - Ledger entries")
("gb" "Bargeld" plain (file (lambda () (expand-file-name (concat db-dir "money.dat"))))
 "%(org-read-date) * Kartenverfügung
    Expenses:Bargeld                           %^{Amount}€
    Assets:Giro"
    :immediate-finish t)
    
("gg" "Giro" plain (file (lambda () (expand-file-name (concat db-dir "money.dat"))))
 "%(org-read-date) * %^{Payee| |Deutsche Bahn}
    Expenses:%^{Expenses|Kauf:|Geschenk:|Reisen:}%^{Expenses}    %^{Amount}€
    Assets:Giro"
    :immediate-finish t)

("gh" "Handy" plain (file (lambda () (expand-file-name (concat db-dir "money.dat"))))
 "%(org-read-date) * Telekom
    Expenses:Handy                             %^{Amount|29,89}€
    Assets:Giro"
    :immediate-finish t)

("gi" "Internet+Telefon" plain (file (lambda () (expand-file-name (concat db-dir "money.dat"))))
 "%(org-read-date) * Kabel Deutschland
    Expenses:Wohnung:Internet+Telefon          %^{Amount|19,90}€
    Assets:Giro" 
    :immediate-finish t)

("gk" "Krankenkasse" plain (file (lambda () (expand-file-name (concat db-dir "money.dat"))))
 "%(org-read-date) * Techniker Krankenkasse
    Expenses:Versicherung:Krankenkasse        240,30€
    Assets:Giro"
    :immediate-finish t)
    
("gm" "Miete" plain (file (lambda () (expand-file-name (concat db-dir "money.dat"))))
 "%(org-read-date) * Unter den Eichen
    Expenses:Wohnung:Grundmiete               402,52€
    Expenses:Wohnung:Heizkosten                83,00€
    Expenses:Wohnung:Betriebskosten           103,00€
    Assets:Giro" 
    :immediate-finish t)

("gn" "Netflix" plain (file (lambda () (expand-file-name (concat db-dir "money.dat"))))
 "%(org-read-date) * Netflix ;;geht beides an Samuel
    Expenses:Unterhaltung:Netflix               3,00€
    Liabilities:Ha-Sa:Netflix                   3,00€
    Assets:Giro"
    :immediate-finish t)

("gu" "Untermiete" plain (file (lambda () (expand-file-name (concat db-dir "money.dat"))))
 "%(org-read-date) * Kevin Schürer (%^{Monat})
    Assets:Giro                               %^{Amount|330,00}€
    Income:Wohnung" 
    :immediate-finish t)
    
("gs" "Strom" plain (file (lambda () (expand-file-name (concat db-dir "money.dat"))))
 "%(org-read-date) * Stadtwerke
    Expenses:Wohnung:Strom                     %^{Amount|59,00}€
    Assets:Giro" 
    :immediate-finish t)
    
("gt" "Topoi Stipendium" plain (file (lambda () (expand-file-name (concat db-dir "money.dat"))))
 "%(org-read-date) * Stipendium Topoi
    Assets:Giro                              %^{Amount|1350,00}€
    Income:Stipendium:Topoi" 
    :immediate-finish t)
     
("z" "Zettel" plain (file (lambda () (capture-report-date-file (expand-file-name zettelkasten-dir))))
 "#+TITLE: %^{Title}
#+DATE: %U\n* Schlagwörter
tags: %^{Type|§content|§index}, \n* Inhalt
%?\n* Literatur\n
\n* Links & Files :children:"
:immediate-finish t :jump-to-captured t)

("Z" "Zettel TODO" entry (file+headline (lambda () (expand-file-name (concat zettelkasten-dir "0-0a~zettelkasten-todo.txt")) "Inhalt"))
 "* TODO %^{Task}
:PROPERTIES:
:CREATED: %U
:CATEGORY: wiss
:END:
[[%l][%f]]
%?")
))
#+end_src

** refile
#+begin_src emacs-lisp
;; Targets include this file and any file contributing to the agenda - up to 9 levels deep
(setq org-refile-targets (quote ((("pers.org") :maxlevel . 3)
                                 (("wiss.org") :maxlevel . 4)
                                 (("irw.org") :maxlevel . 4)
                                 (("~/Dropbox/diss/diss.org") :maxlevel . 4)
                                 (("antiq.org") :maxlevel . 2)
                                 (("~/Dropbox/db/contacts.org") :maxlevel . 2)
                                 (("goals.org") :maxlevel . 2))
))

(setq org-outline-path-complete-in-steps nil)         ; Refile in a single go
(setq org-refile-use-outline-path t)                  ; Show full paths for refiling

; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))
#+end_src

** tags
#+begin_src emacs-lisp
; Tags with fast selection keys
(setq org-tags-exclude-from-inheritance '("txt"))

(setq org-tag-alist (quote ((:startgroup)
                            ("@home" . ?h)
                            (:endgroup)
                            (:startgroup)
                            ("today" . ?t)
                            ("someday" . ?s)
                            (:endgroup)
)))

; Allow setting single tags without the menu
(setq org-fast-tag-selection-single-key (quote expert))
#+end_src
** dependencies
#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies t)
(setq org-enforce-todo-checkbox-dependencies t)
#+end_src
** deadlines
#+begin_src emacs-lisp
(setq org-deadline-warning-days 14) ;; Default Spanne bei Deadlines
#+end_src
** drawers & logging
#+begin_src emacs-lisp
(setq org-drawers (quote ("PROPERTIES" "LOGBOOK" "CLOCK")))
(setq org-clock-into-drawer "CLOCK")
(setq org-log-into-drawer "LOGBOOK")

(setq org-log-refile 'time)
(setq org-log-reschedule 'time)
(setq org-log-redeadline 'time)
(setq org-log-done 'time)
#+end_src
*** global propertie values: effort, habit
#+begin_src emacs-lisp
; global Effort estimate values
; global STYLE property values for completion
(setq org-global-properties (quote (("Effort_ALL" . "0:10 0:15 0:20 0:30 0:45 1:00 1:30 2:00 3:00 4:00 5:00 6:00 7:00 8:00")
                                    ("STYLE_ALL" . "habit"))))

;; property inheritance
(setq org-use-property-inheritance (quote ("QUANTIFIED")))
#+end_src
** clocking
*** config
#+begin_src emacs-lisp
  (setq org-clock-history-length 42)
  (setq org-clock-out-when-done t)
  (setq org-clock-out-remove-zero-time-clocks t)

  ;; Keep clock durations in hours
  (setq org-time-clocksum-format
        (quote(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t)))

  ;; Resume clocking tasks when emacs is restarted
  (org-clock-persistence-insinuate)

  ;; Include current clocking task in clock reports
  (setq org-clock-report-include-clocking-task t)

  ;; Resume clocking task on clock-in if the clock is open
  (setq org-clock-in-resume t)
  ;; Save the running clock and all clock history when exiting Emacs,
  ;; load it on startup
  (setq org-clock-persist t)

  ;; When non-nil, ask before resuming any stored clock during load.
  (setq org-clock-persist-query-resume nil)
#+end_src

http://doc.norang.ca/org-mode.org
#+begin_src emacs-lisp
  (setq bh/keep-clock-running nil)

  (defun bh/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))

  (defun bh/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
      (and is-a-task has-subtask))))

  (defun bh/find-project-task ()
    "Move point to the parent (project) task if any"
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char parent-task)
        parent-task)))

  (defun bh/punch-in (arg)
    "Start continuous clocking and set the default task to the
  selected task.  If no task is selected set the Organization task
  as the default task."
    (interactive "p")
    (setq bh/keep-clock-running t)
    (pomodoro)
    (if (equal major-mode 'org-agenda-mode)
        ;;
        ;; We're in the agenda
        ;;
        (let* ((marker (org-get-at-bol 'org-hd-marker))
               (tags (org-with-point-at marker (org-get-tags-at))))
          (if (and (eq arg 4) tags)
              (org-agenda-clock-in '(16))
            (bh/clock-in-organization-task-as-default)))
      ;;
      ;; We are not in the agenda
      ;;
      (save-restriction
        (widen)
        ; Find the tags on the current task
        (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
            (org-clock-in '(16))
          (bh/clock-in-organization-task-as-default))))
    (delete-other-windows)
    (switch-to-buffer-other-window "*Org Agenda*")
  )

  (defun bh/punch-out ()
    (interactive)
    (setq bh/keep-clock-running nil)
    (when (org-clock-is-active)
      (org-clock-out))
    (org-agenda-remove-restriction-lock)
    (pomodoro-stop)
  )

;;https://github.com/mattfidler/my-emacs-startup/blob/master/startup-org.org
  (defun job/punch-in-or-out (arg)
    (interactive "p")
    (if bh/keep-clock-running
        (bh/punch-out)
      (bh/punch-in arg)))

  (defun bh/clock-in-default-task ()
    (save-excursion
      (org-with-point-at org-clock-default-task
        (org-clock-in))))

  (defun bh/clock-in-parent-task ()
    "Move point to the parent (project) task if any and clock in"
    (let ((parent-task))
      (save-excursion
        (save-restriction
          (widen)
          (while (and (not parent-task) (org-up-heading-safe))
            (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
              (setq parent-task (point))))
          (if parent-task
              (org-with-point-at parent-task
                (org-clock-in))
            (when bh/keep-clock-running
              (bh/clock-in-default-task)))))))

  (defvar bh/organization-task-id "5194bc56-17d0-42e7-85c1-0889402671aa")

  (defun bh/clock-in-organization-task-as-default ()
    (interactive)
    (org-with-point-at (org-id-find bh/organization-task-id 'marker)
      (org-clock-in '(16))))

  (defun bh/clock-out-maybe ()
    (when (and bh/keep-clock-running
               (not org-clock-clocking-in)
               (marker-buffer org-clock-default-task)
               (not org-clock-resolving-clocks-due-to-idleness))
      (bh/clock-in-parent-task)))

  (add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)

  (bind-key "C-c <f11>" 'job/punch-in-or-out)
#+end_src

*** org-clock-convenience
#+begin_src emacs-lisp
(use-package org-clock-convenience
  :ensure t
  :bind (:map org-agenda-mode-map
   	   ("<C-S-up>" . org-clock-convenience-timestamp-up)
   	   ("<C-S-down>" . org-clock-convenience-timestamp-down)
   	   ("ö" . org-clock-convenience-fill-gap)
   	   ("ä" . org-clock-convenience-fill-gap-both)))
#+end_src

** timer
#+begin_src emacs-lisp
(setq org-timer-default-timer 25)
#+end_src
** aufzählungszeichen
#+begin_src emacs-lisp
;; Aufzählungszeichen wechseln durch
(setq org-list-demote-modify-bullet '(("-" . "+")
                                            ("+" . "-")
                                            ("1." . "A.")
				  	        ("A." . "1.")
                                            ("1)" . "-")
                                            ("A)" . "-")
                                            ("B)" . "-")
                                            ("a)" . "-")
                                            ("b)" . "-")
                                            ("B." . "-")
                                            ("a." . "-")
                                            ("b." . "-")))
#+end_src
** columns
#+begin_src emacs-lisp
; Set default column view headings: Task Effort Clock_Summary
(setq org-columns-default-format "%50ITEM(Task) %6Effort(Effort){:} %6CLOCKSUM_T(Today) %6CLOCKSUM(Sum)")
#+end_src

** calendar
#+begin_src emacs-lisp
(use-package german-holidays
  :config
   (setq holiday-other-holidays holiday-german-holidays))

(setq calendar-latitude 52.450894)
(setq calendar-longitude 13.308570)
(setq calendar-location-name "Berlin")

(setq calendar-time-display-form '(24-hours ":" minutes))
#+end_src
** export
*** ox-pandoc
#+begin_src emacs-lisp
;;(use-package ox-pandoc
;;  :defer t)
#+end_src

*** LaTeX-Export
#+begin_src emacs-lisp
(require 'ox-latex)
(setq org-latex-listings t)
(add-to-list 'org-latex-packages-alist '("" "booktabs" t))
(add-to-list 'org-latex-packages-alist '("" "ellipsis" t))
(add-to-list 'org-latex-packages-alist '("" "csquotes" t))
(add-to-list 'org-latex-packages-alist '("" "lmodern" t))
(add-to-list 'org-latex-packages-alist '("onehalfspacing" "setspace" t))
(add-to-list 'org-latex-packages-alist '("" "microtype" t))
(add-to-list 'org-latex-packages-alist '("english, ngerman" "babel" t))
(add-to-list 'org-latex-packages-alist '("T1" "fontenc" t))
(add-to-list 'org-latex-packages-alist '("utf8" "inputenc" t))


(add-to-list 'org-latex-classes
      '("scrartcl"
         "\\RequirePackage[l2tabu, orthodox]{nag}
          \\documentclass[DIV12, a4paper, 12pt]{scrartcl}
         [NO-DEFAULT-PACKAGES]
         [PACKAGES]
         [EXTRA]"
         ("\\section{%s}" . "\\section*{%s}")
         ("\\subsection{%s}" . "\\subsection*{%s}")
         ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
(add-to-list 'org-latex-classes
      '("scrbook"
         "\\RequirePackage[l2tabu, orthodox]{nag}
          \\documentclass[DIV=12, a4paper, 12pt]{scrbook}
         [NO-DEFAULT-PACKAGES]
         [NO-PACKAGES]
         [EXTRA]"
         ("\\part{%s}" . "\\part*{%s}")
         ("\\chapter{%s}" . "\\chapter*{%s}")
         ("\\section{%s}" . "\\section*{%s}")
         ("\\subsection{%s}" . "\\subsection*{%s}")
         ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
         ("\\paragraph{%s}" . "\\paragraph*{%s}")
         ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
(add-to-list 'org-latex-classes
      '("abrechnung"
         "\\documentclass[DIV=12, a4paper, 12pt]{scrartcl}
          \\usepackage{marvosym}
         [NO-DEFAULT-PACKAGES]
         [PACKAGES]
         [EXTRA]"
         ("\\section{%s}" . "\\section*{%s}")
         ("\\subsection{%s}" . "\\subsection*{%s}")
         ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
(add-to-list 'org-latex-classes
      '("zettel"
         "\\documentclass[DIV=12, a4paper, 12pt, headings=normal]{scrartcl}
          \\usepackage{enumitem}
          \\setlist[itemize]{itemsep=-0.5ex}
         \\makeatletter
         \\def\\maketitle{{\\centering%
         \\par{\\large\\bfseries\\@title\\par\\bigskip}%
         \\noindent}}
         \\makeatother
         [NO-DEFAULT-PACKAGES]
         [PACKAGES]
         [EXTRA]"
         ("\\section{%s}" . "\\section*{%s}")
         ("\\subsection*{%s}" . "\\subsection*{%s}")
         ("\\subsubsection*{%s}" . "\\subsubsection*{%s}")))

(setq org-latex-default-class "zettel")
(setq org-export-with-author t)
(setq org-export-with-date t)
(setq org-export-with-toc nil)
(setq org-latex-hyperref-template nil)
(setq org-latex-tables-booktabs t)
(setq org-export-default-language "en")
(setq org-export-with-smart-quotes t)
(add-to-list 'org-export-smart-quotes-alist 
             '("en"
               (opening-double-quote :utf-8 "“" :html "&ldquo;" :latex "\\enquote{" :texinfo "``")
               (closing-double-quote :utf-8 "”" :html "&rdquo;" :latex "}" :texinfo "''")
               (opening-single-quote :utf-8 "‘" :html "&lsquo;" :latex "\\enquote*{" :texinfo "`")
               (closing-single-quote :utf-8 "’" :html "&rsquo;" :latex "}" :texinfo "'")
               (apostrophe :utf-8 "’" :html "&rsquo;")));; Export von "" und '' zu csquotes
#+end_src

** X org-drill
#+begin_src emacs-lisp
;;(use-package org-drill)
#+end_src
** org-ref
#+begin_src emacs-lisp
(use-package org-ref
:init
 (bind-key "C-c )" 'org-autocite-complete-link org-mode-map)
 (setq org-ref-completion-library 'org-ref-ivy-cite)

:config
 (progn
   (require 'org-ref)
   (setq org-ref-notes-directory (expand-file-name zettelkasten-dir))
   (setq org-ref-default-bibliography '("~/Dropbox/db/biblio.bib"))
   (setq org-ref-pdf-directory (expand-file-name texte-dir))
   (setq org-ref-default-citation-link "autocite")
))

#+end_src

** org-clock-csv
#+begin_src emacs-lisp
  (use-package org-clock-csv
    :load-path "~/.emacs.d/non-elpa/org-clock-csv"
    :config
      (defun my/org-clock-csv-calc ()
        "Ruft script auf und verarbeitet die "
        (interactive)
        (shell-command "source ~/script/clock-entries.sh"))

      (defun my/org-clock-csv-write-calc ()
        (interactive)
        (org-clock-csv)
        (my/org-clock-csv-calc)))
#+end_src

** org-present
#+begin_src emacs-lisp
(eval-after-load "org-present"
  '(progn
     (add-hook 'org-present-mode-hook
               (lambda ()
                 (org-present-big)
                 (org-display-inline-images)
                 (flyspell-mode -1)
                 (variable-pitch-mode t)
                 (visual-fill-column-mode t)))
     (add-hook 'org-present-mode-quit-hook
               (lambda ()
                 (org-present-small)
                 (org-remove-inline-images)
                 (flyspell-mode 1)
                 (variable-pitch-mode 0)
                 (visual-fill-column-mode 0)
                 ))))
#+end_src

** org-contacts
#+begin_src emacs-lisp
(use-package org-contacts
 :init
(setq org-contacts-files '("~/Dropbox/db/contacts.org"))
)
#+end_src

** org-attach
#+begin_src emacs-lisp
(setq org-attach-directory "~/Dropbox/db/data/")
(setq org-attach-expert t)
(setq org-attach-method 'lns)
#+end_src

** org-babel
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages '((shell . t)))

  (defun my-org-confirm-babel-evaluate (lang body)
    (not (string= lang "sh")))  ; don't ask for shell
  (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
#+end_src


* LaTeX und BibTeX
** auctex
#+begin_src emacs-lisp
(use-package tex-site
  :defer t
  :mode ("\\.tex\\'" . LaTeX-mode)
  :config
   (progn
	(setq TeX-auto-save	t)
	(setq TeX-parse-self	t)
	(setq TeX-PDF-mode	t)
    
    ;; Use pdf-tools to open PDF files
    (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
          TeX-source-correlate-start-server t)
    
    ;; Update PDF buffers after successful LaTeX runs
    (add-hook 'TeX-after-TeX-LaTeX-command-finished-hook
             #'TeX-revert-document-buffer)

    (setq LaTeX-csquotes-open-quote "\\enquote{")
	(setq LaTeX-csquotes-close-quote "}")
    (setq LaTeX-paragraph-commands '("…")) ;; Befehle, bei 'fill' eigene paragraphen bilden

    (setq LaTeX-babel-hyphen nil); Disable language-specific hyphen insertion.

    ;; TeX-fold-mode
    (add-hook 'TeX-mode-hook
         (lambda () (TeX-fold-mode 1))); Automatically activate TeX-fold-mode.

    (custom-set-variables
      '(TeX-fold-macro-spec-list
        '(("[f]"     ("sidenote"))
          ("[fn]"    ("footnote" "marginpar"))
          ("[ac]"    ("autocite" "avolcite")) ;; new
          ("[c]"     ("cite"))
          ("[l]"     ("label"))
          ("[r]"     ("ref" "pageref" "eqref"))
          ("[i]"     ("index" "glossary"))
          ("[1]:||--"  ("item"))
          ("…"       ("dots"))
          ("(C)"     ("copyright"))
          ("(R)"     ("textregistered"))
          ("TM"      ("texttrademark"))
          ("\"{1}\"" ("enquote"))
          ("'{1}'"   ("enquote*"))
          ("\"{2}\"" ("blockcquote"))
          ("\"{1}\"" ("chapname"))
          ("'{1}'"   ("uneigtl"))
          (1         ("part" "part*" "chapter" "chapter*"
                      "section" "section*" "subsection" "subsection*"
                      "subsubsection" "subsubsection*"
                      "paragraph" "paragraph*" "subparagraph" "subparagraph*"
                      "emph" "textit" "textsl" "textmd" "textrm"
                      "textsf" "texttt" "textbf" "textsc" "textup")))))
    ;;SyncTeX
    (setq TeX-source-correlate-mode 'synctex)

	(add-hook 'LaTeX-mode-hook 'flyspell-mode)
	(add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
	(add-hook 'LaTeX-mode-hook 'latex-extra-mode)
    (add-hook 'LaTeX-mode-hook 'visual-fill-column-mode)



    (add-hook 'LaTeX-mode-hook 
         (lambda()
            (add-to-list 'TeX-command-list '("Latexmk" "%`latexmk -pdf %t" TeX-run-TeX nil t))
            (setq TeX-save-query nil)
            (setq TeX-show-compilation t)))

    (add-hook 'LaTeX-mode-hook 
         (lambda()
            (add-to-list 'TeX-command-list '("Latex -se" "%`pdflatex --synctex=1 -shell-escape %t" TeX-run-TeX nil t))
            (setq TeX-save-query nil)
            (setq TeX-show-compilation t)))

      (add-hook 'LaTeX-mode-hook 
          (lambda()
             (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex --synctex=1 %(mode)%' %t" TeX-run-TeX nil t))
             (setq TeX-save-query nil)
             (setq TeX-show-compilation t)))
))

(use-package latex-extra
 :defer t
 :diminish latex-extra-mode)
#+end_src

** reftex
#+begin_src emacs-lisp
(use-package reftex
  :diminish reftex-mode
  :config
    (progn
	(setq reftex-plug-into-AUCTeX t)
	(setq reftex-sort-bibtex-matches "author")
	(setq reftex-external-file-finders
	      '(("tex" . "kpsewhich -format=.tex %f")
        	("bib" . "kpsewhich -format=.bib %f")))
    (setq reftex-default-bibliography '("~/Dropbox/db/biblio.bib"))
	(setq reftex-cite-format
		'((?\C-m . "\\autocite[][]{%l}")
		  (?c . "\\cite[][]{%l}")
		  (?t . "\\textcite[][]{%l}")
		  (?y . "\\autocite*[][]{%l}")
		  (?n . "\\nocite{%l}")
		  (?f . "\\footcite[][]{%l}")
              (?T . "\\textcquote[][]{%l}[]{")
              (?B . "\\blockcquote[][]{%l}[]{")))
    (setq reftex-cite-prompt-optional-args t)
    (setq reftex-cite-cleanup-optional-arg t)
	(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
	(add-hook 'latex-mode-hook 'turn-on-reftex)
))
#+end_src

** bibtex-mode
http://www.jonathanleroux.org/bibtex-mode.html
#+begin_src emacs-lisp
(setq bibtex-dialect 'biblatex)
(setq bibtex-maintain-sorted-entries t)
(setq bibtex-autokey-year-use-crossref-entry t
      bibtex-autokey-year-length 4
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-")

(defun bibtex-autokey-get-year ()
  "Return year field contents as a string obeying `bibtex-autokey-year-length'."
  (let ((yearfield (bibtex-autokey-get-field "date")))
    (substring yearfield (max 0 (- (length yearfield)
                                   bibtex-autokey-year-length)))))
#+end_src

** bibtex-utils
#+begin_src emacs-lisp
(use-package bibtex-utils
 :ensure t)
#+end_src

** gscholar-bibtex
#+begin_src emacs-lisp
(use-package gscholar-bibtex
 :config
 (setq gscholar-bibtex-database-file (expand-file-name db-dir "import.bib"))
 (setq gscholar-bibtex-default-source "Google Scholar"))
#+end_src

** bibtex-completion
#+begin_src emacs-lisp
(use-package bibtex-completion
  :config
   (setq bibtex-completion-bibliography (expand-file-name job/bibliography-file))
   (setq bibtex-completion-library-path (expand-file-name texte-dir))
   (setq bibtex-completion-pdf-field "Files")
   (setq bibtex-completion-notes-path (expand-file-name zettelkasten-dir))
   (setq bibtex-completion-notes-extension ".txt")
   (setq bibtex-completion-additional-search-fields '("subtitle"
                                                      "date"
                                                      "keywords"))

   (setq bibtex-completion-cite-default-command "autocite")

   (setq bibtex-completion-pdf-open-function
     (lambda (fpath)
      (start-process "evince" "*bibtex-evince*" "/usr/bin/evince" fpath)))

   (setq bibtex-completion-notes-template-multiple-files "#+TITLE: ${author} ${date}: ${title}\n#+DATE: [${timestamp}]\n* Schlagwörter\ntags: §${=key=}, §txt, ${keywords},\n\n* Inhalt\n\n* Literatur\n\n* Links & Files :children:\n- [[file:~/Dropbox/db/biblio.bib::${=key=}][BibTeX Entry]]\n- [[file:~texte/${=key=}*][Files]]\n- [[file:~/Dropbox/db/stats/zettelkasten/zettel-similarities/sim-${=key=}.txt][Similarities]]\n\n* Data\n** misc\n#+begin_src csv :tangle zettel-txt-references-path.csv :padline no\n${source}, ${=key=}\n#+end_src")

  (setq bibtex-completion-format-citation-functions
     '((org-mode      . bibtex-completion-format-citation-org-ref-autocite)
       (latex-mode    . bibtex-completion-format-citation-cite)
       (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
       (default       . bibtex-completion-format-citation-default)))

  (defun bibtex-completion-format-citation-org-ref-autocite (keys)
     "Formatter for org-ref references."
     (let* ((prenote  (if bibtex-completion-cite-prompt-for-optional-arguments (read-from-minibuffer "Prenote: ") ""))
            (postnote (if bibtex-completion-cite-prompt-for-optional-arguments (read-from-minibuffer "Postnote: ") ""))
            (prenote  (if (string= "" prenote)  "" (concat prenote  "::")))
            (notes (if (string= "" postnote) "" (concat "[" prenote postnote "]"))))
      (format "[[autocite:%s]%s]" (s-join ", " keys) notes)))

  (defun bibtex-completion-apa-get-value (field entry &optional default)
     "Return FIELD or ENTRY formatted following the APA
   guidelines.  Return DEFAULT if FIELD is not present in ENTRY."
     (let ((value (bibtex-completion-get-value field entry))
           (entry-type (bibtex-completion-get-value "=type=" entry)))
       (if value
          (pcase field
            ;; https://owl.english.purdue.edu/owl/resource/560/06/
            ("author" (bibtex-completion-apa-format-authors value))
            ("editor"
             (if (string= entry-type "proceedings")
                 (bibtex-completion-apa-format-editors value)
               (bibtex-completion-apa-format-editors value)))
            ;; When referring to books, chapters, articles, or Web pages,
            ;; capitalize only the first letter of the first word of a
            ;; title and subtitle, the first word after a colon or a dash
            ;; in the title, and proper nouns. Do not capitalize the first
            ;; letter of the second word in a hyphenated compound word.
            ("title" (replace-regexp-in-string ; remove braces
                      "[{}]"
                      "" value))
            ("booktitle" value)
            ;; Maintain the punctuation and capitalization that is used by
            ;; the journal in its title.
            ("pages" (s-join "--" (s-split "[^0-9]+" value t)))
            ("doi" (s-concat " http://dx.doi.org/" value))
            (_ value))
         "")))

  (defun bibtex-completion-format-entry (entry width)
     "Formats a BibTeX entry for display in results list."
     (let* ((fields (list (if (assoc-string "author" entry 'case-fold) "author" "editor")
                          "title" "date" "=has-pdf=" "=has-note=" "=type="))
            (fields (-map (lambda (it)
                            (bibtex-completion-clean-string
                             (bibtex-completion-get-value it entry " ")))
                          fields))
            (fields (-update-at 0 'bibtex-completion-shorten-authors fields)))
       (s-format "$0 $1 $2 $3$4 $5" 'elt
                 (-zip-with (lambda (f w) (truncate-string-to-width f w 0 ?\s))
                            fields (list 36 (- width 53) 4 1 1 7)))))

  (defun bibtex-completion-apa-format-reference (key)
     "Returns a plain text reference in APA format for the publication specified by KEY."
     (let*
      ((entry (bibtex-completion-get-entry key))
       (ref (pcase (downcase (bibtex-completion-get-value "=type=" entry))
              ("article"
               (s-format
                "${author} ${date}: ${title}. ${subtitle}. In: ${journaltitle}, ${volume}(${number}), ${pages}. ([[file:${=key=}.txt][Zettel]])"
                'bibtex-completion-apa-get-value entry))
              ("inproceedings"
               (s-format
                "${author} ${date}: ${title}. ${subtitle}. In: ${editor} (Hg.): [${crossref}] ${location}: ${publisher}, ${pages}. ([[file:${=key=}.txt][Zettel]])"
                'bibtex-completion-apa-get-value entry))
              ("book"
               (s-format
                "${author} ${date}: ${title}. ${subtitle}. ${location}: ${publisher}. ([[file:${=key=}.txt][Zettel]])"
                'bibtex-completion-apa-get-value entry))
              ("collection"
               (s-format
                "${editor} (Hg.) ${date}: ${title}. ${subtitle}. ${location}: ${publisher}. ([[file:${=key=}.txt][Zettel]])"
                'bibtex-completion-apa-get-value entry))
              ("phdthesis"
               (s-format
                "${author} ${year}: ${title}. ${subtitle}. (Doctoral dissertation). ${school}, ${location}. ([[file:${=key=}.txt][Zettel]])"
                'bibtex-completion-apa-get-value entry))
              ("inbook"
               (s-format
                "${author} ${date}: ${title}. ${subtitle}. In: [${crossref}] ${location}: ${publisher}, ${pages}. ([[file:${=key=}.txt][Zettel]])"
                'bibtex-completion-apa-get-value entry))
              ("incollection"
               (s-format
                "${author} ${date}: ${title}. ${subtitle}. In: ${editor} (Hg.): [${crossref}] ${location}: ${publisher}, ${pages}. ([[file:${=key=}.txt][Zettel]])"
                'bibtex-completion-apa-get-value entry))
              ("proceedings"
               (s-format
                "${editor} (Hg.) ${date}: ${title}. ${location}: ${publisher}. ([[file:${=key=}.txt][Zettel]])"
                'bibtex-completion-apa-get-value entry))
              ("unpublished"
               (s-format
                "${author} ${date}: ${title}. ${subtitle}. Unpublished manuscript. ([[file:${=key=}.txt][Zettel]])"
                'bibtex-completion-apa-get-value entry))
              ("online"
               (s-format
                "${author} ${date}: ${title}. ${subtitle}. , ${url}. ([[file:${=key=}.txt][Zettel]])"
                'bibtex-completion-apa-get-value entry))
              (_
               (s-format
                "${author} ${date}: ${title}. ${subtitle}. ([[file:${=key=}.txt][Zettel]])"
                'bibtex-completion-apa-get-value entry)))))
      (replace-regexp-in-string "\\([ .?!]\\)\\." "\\1" ref))) ; Avoid sequences of punctuation marks.


;; Eigene Aktion für Logs
(defcustom bibtex-completion-logs-extension "--log.txt"
  "The extension of the files containing notes.  This is only
used when `bibtex-completion-notes-path' is a directory (not a file)."
  :group 'bibtex-completion
  :type 'string)

(defcustom bibtex-completion-logs-template-multiple-files
  "#+TITLE: Log: ${author} ${date}: ${title}\n#+DATE: [${timestamp}]\n\n"
  "Template used to create a new log when each note is stored in
a separate file.  '${field-name}' can be used to insert the value
of a BibTeX field into the template. Fork."
  :group 'bibtex-completion
  :type 'string)

(defun bibtex-completion-edit-logs (keys)
  "Open the log  associated with the selected entries using `find-file'. Fork from edit-notes"
  (dolist (key keys)
    (if (and bibtex-completion-notes-path
             (f-directory? bibtex-completion-notes-path))
                                        ; One log file per publication:
        (let* ((path (f-join bibtex-completion-notes-path
                             (s-concat key bibtex-completion-logs-extension))))
          (find-file path)
          (unless (f-exists? path)
            (insert (s-format bibtex-completion-logs-template-multiple-files
                              'bibtex-completion-apa-get-value
                              (bibtex-completion-get-entry key)))))
                                        ; One file for all logs:
      (unless (and buffer-file-name
                   (f-same? bibtex-completion-notes-path buffer-file-name))
        (find-file-other-window bibtex-completion-notes-path))
      (widen)
      (show-all)
      (goto-char (point-min))
      (if (re-search-forward (format bibtex-completion-notes-key-pattern (regexp-quote key)) nil t)
                                        ; Existing entry found:
          (when (eq major-mode 'org-mode)
            (org-narrow-to-subtree)
            (re-search-backward "^\*+ " nil t)
            (org-cycle-hide-drawers nil)
            (bibtex-completion-notes-mode 1))
                                        ; Create a new entry:
        (let ((entry (bibtex-completion-get-entry key)))
          (goto-char (point-max))
          (insert (s-format bibtex-completion-notes-template-one-file
                            'bibtex-completion-apa-get-value
                            entry)))
        (when (eq major-mode 'org-mode)
          (org-narrow-to-subtree)
          (re-search-backward "^\*+ " nil t)
          (org-cycle-hide-drawers nil)
          (goto-char (point-max))
          (bibtex-completion-notes-mode 1))))))

)
#+end_src

** ivy-bibtex
#+begin_src emacs-lisp
(use-package ivy-bibtex
 :ensure t
 :bind (("C-c b" . ivy-bibtex)
        ("C-<f5>" . ivy-resume))
 :config
  (setq ivy-bibtex-default-action 'ivy-bibtex-insert-citation)

  (ivy-bibtex-ivify-action bibtex-completion-edit-logs ivy-bibtex-edit-logs)
  (ivy-add-actions
   'ivy-bibtex
   '(("E" ivy-bibtex-edit-logs "Edit log")))
)
#+end_src

** texcount
#+begin_src emacs-lisp
(defun my-latex-setup ()
  (defun latex-word-count ()
    (interactive)
    (let* ((this-file (buffer-file-name))
           (word-count
            (with-output-to-string
              (with-current-buffer standard-output
                (call-process "texcount" nil t nil "-sum" "-inc" "-sub=none" this-file)))))
      (string-match "\n$" word-count)
      (message (replace-match "" nil nil word-count))))
    (define-key LaTeX-mode-map "\C-cw" 'latex-word-count)
  (defun latex-word-count-details ()
    (interactive)
    (let* ((this-file (buffer-file-name))
           (word-count
            (with-output-to-string
              (with-current-buffer standard-output
                (call-process "texcount" nil t nil "-sum" "-inc" "-sub=section" this-file)))))
      (string-match "\n$" word-count)
      (message (replace-match "" nil nil word-count))))
    (define-key LaTeX-mode-map "\C-cW" 'latex-word-count-details))
(add-hook 'LaTeX-mode-hook 'my-latex-setup t)
#+end_src

* Schreiben und Stil
** ispell
#+begin_src emacs-lisp
(use-package ispell
  :config
  (progn
    (setq-default ispell-program-name "aspell")
    (setq ispell-dictionary "german")
    (setq ispell-personal-dictionary (expand-file-name (concat user-emacs-directory ".customdict-de")))
;;	(setq ispell-extra-args '("--dont-tex-check-comments"))
;;  (setq ispell-parser 'tex)
))
#+end_src

** flyspell
#+begin_src emacs-lisp
(use-package flyspell
  :diminish flyspell-mode
  :bind (("C-c s" . my/flyspell-check-previous-highlighted-word)
         ("C-c S" . my/flyspell-check-next-highlighted-word))
  :config
   (dolist (hook '(org-mode-hook))
     (add-hook hook (lambda() (flyspell-mode 1))))
   (dolist (hook '(text-mode-hook))
     (add-hook hook (lambda () (flyspell-mode 1))))
   (dolist (hook '(change-log-mode-hook log-edit-mode-hook))
     (add-hook hook (lambda () (flyspell-mode -1))))

   (setq flyspell-tex-command-regexp "\\(\\(begin\\|end\\)[ \t]*{\\|\\(cite[.*]*\\|autocite[.*]*\\|label\\|ref\\|eqref\\|usepackage\\|documentclass\\|addbibresource\\|pagestyle\\|KOMAoptions\\|setkomafont\\|newclassic\\|printbibliography\\)[ \t]*\\(\\[[^]]*\\]\\)?{[^{}]*\\)")

   (defun my/flyspell-check-previous-highlighted-word (&optional arg)
      "Correct the closer misspelled word.
    This function scans a mis-spelled word before the cursor. If it finds one
    it proposes replacement for that word. With prefix arg, count that many
    misspelled words backwards."
      (interactive)
      (let ((pos1 (point))
    	(pos  (point))
    	(arg  (if (or (not (numberp arg)) (< arg 1)) 1 arg))
    	ov ovs)
        (if (catch 'exit
    	  (while (and (setq pos (previous-overlay-change pos))
    		      (not (= pos pos1)))
    	    (setq pos1 pos)
    	    (if (> pos (point-min))
    		(progn
    		  (setq ovs (overlays-at (1- pos)))
    		  (while (consp ovs)
    		    (setq ov (car ovs))
    		    (setq ovs (cdr ovs))
    		    (if (and (flyspell-overlay-p ov)
    			     (= 0 (setq arg (1- arg))))
    			(throw 'exit t)))))))
    	(save-excursion
    	  (goto-char pos)
    	  (flyspell-correct-word-generic)
    	  (setq flyspell-word-cache-word nil) ;; Force flyspell-word re-check
    	  (flyspell-word))
          (error "No word to correct before point"))))


   (defun my/flyspell-check-next-highlighted-word ()
      "Custom function to spell check next highlighted word"
       (interactive)
       (flyspell-goto-next-error)
       (flyspell-correct-word-generic)
  	   (setq flyspell-word-cache-word nil))
)

;; http://www.emacswiki.org/emacs/FlySpell
;;(bind-key "<f10>" 'ispell-word)
;;(bind-key "C-c f p" 'flyspell-check-previous-highlighted-word)
;;(bind-key "C-<f10>" 'flyspell-check-next-highlighted-word)
;;(bind-key "C-c f m" 'flyspell-mode)
;;(bind-key "C-c f b" 'flyspell-buffer)

#+end_src

** flyspell-correct
#+begin_src emacs-lisp
(use-package flyspell-correct
  :ensure t
  :config
   (setq flyspell-correct-interface 'flyspell-correct-ivy))

(use-package flyspell-correct-ivy
  :ensure t)
#+end_src
** writegood
#+begin_src emacs-lisp
(use-package writegood-mode
  :config
   (progn
    (setq writegood-weasel-words
     '("wichtig" "wichtige" "vielleicht" "auch" "dabei" "sehr" "ziemlich" "möglicherweise" "wohl" "recht" "dann" "paar" "bisschen"))
    (setq writegood-passive-voice-irregulars
     '("gemacht" "geworden" "vorgenommen" "durchgeführt"))))
#+end_src

** languagetool
#+begin_src emacs-lisp
(use-package langtool
  :init
   (setq langtool-language-tool-jar "~/programme/LanguageTool-3.1/languagetool-commandline.jar"))
#+end_src

** ispell-abbrev
http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html
#+begin_src emacs-lisp
(define-key ctl-x-map "\C-i"
  #'endless/ispell-word-then-abbrev)

(defun endless/ispell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
  (interactive "P")
  (let (bef aft)
    (save-excursion
      (while (if (setq bef (thing-at-point 'word))
                 ;; Word was corrected or used quit.
                 (if (ispell-word nil 'quiet)
                     nil ; End the loop.
                   ;; Also end if we reach `bob'.
                   (not (bobp)))
               ;; If there's no word at point, keep looking
               ;; until `bob'.
               (not (bobp)))
        (backward-word))
      (setq aft (thing-at-point 'word)))
    (if (and aft bef (not (equal aft bef)))
        (let ((aft (downcase aft))
              (bef (downcase bef)))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob")))
      (user-error "No typo at or before point"))))
#+end_src

** google-translate
#+begin_src emacs-lisp
(use-package google-translate
  :init
   (require 'google-translate-smooth-ui)
   (setq google-translate-translation-directions-alist
         '(("de" . "en") ("en" . "de") ("de" . "fr") ("fr" . "de")))
   (setq google-translate-output-destination nil)
)
#+end_src

** www-synonyms
#+begin_src emacs-lisp
(use-package www-synonyms
  :config
  (require 'www-synonyms)
  (setq www-synonyms-key "gaGF6dLppnG6whJVPKFg")
  (setq www-synonyms-change-lang "de") ;; funktioniert nicht
)
#+end_src

* Versionskontrolle
** undo-tree
#+begin_src emacs-lisp
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :bind ("C-x u" . undo-tree-visualize)
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t))
)
#+end_src

** magit
#+begin_src emacs-lisp
(use-package magit
 :bind (("C-x g" . magit-status))
 :config
   (setq magit-last-seen-setup-instructions "1.4.0")
   (setq magit-diff-refine-hunk 'all)
   (setq magit-repository-directories
      `(("~/.xmonad")
        (,zettelkasten-dir)
        (,user-emacs-directory)
        ("~/Dropbox/diss")
        ("~/Dropbox/db")
        ))
)
#+end_src

** git-wip
#+begin_src emacs-lisp
(use-package git-wip-mode
  :load-path "~/.emacs.d/non-elpa/git-wip/emacs/"
  :diminish git-wip-mode
  :commands git-wip-mode)
#+end_src

** git-messenger
#+begin_src emacs-lisp
(use-package git-messenger)
#+end_src

** git-timemachine
#+begin_src emacs-lisp
(use-package git-timemachine)
#+end_src

** git-wip-timemachine
#+begin_src emacs-lisp
(use-package git-wip-timemachine)
#+end_src

* Mail und Kontakte
** offlineimap
#+begin_src emacs-lisp
  (require 'offlineimap)
  (add-hook 'gnus-before-startup-hook 'offlineimap)
  (setq offlineimap-mode-line-style 'symbol)
#+end_src

** BBDB
#+begin_src emacs-lisp
(use-package bbdb
  :config
    (progn
;;     (bbdb-initialize 'gnus 'message)
     (bbdb-mua-auto-update-init 'gnus)
     (setq bbdb-file (expand-file-name (concat db-dir "bbdb")))
     (setq bbdb-north-american-phone-numbers-p nil)
     (setq bbdb-default-country "Deutschland")
     (setq bbdb-user-mail-names
       (regexp-opt '("jobangen@gmail.com")))
;;     (bbdb-insinuate-message)
     (setq bbdb-complete-mail-allow-cycling t)
     (setq bbdb-completion-display-record nil)
     (setq bbdb-complete-name-full-completion t)
     (setq bbdb-completion-type 'primary-or-name)
     (setq bbdb-use-pop-up nil)
     (setq bbdb-mua-pop-up t)
     (setq bbdb-mua-update-interactive-p '(query . create))
     (setq bbdb-message-all-addresses t)
     (setq bbdb-layout 'multi-line)
     (setq bbdb-pop-up-layout 'one-line)
))
#+end_src
** gnus-dired
#+begin_src emacs-lisp
(use-package gnus-dired
  :config
   (progn
     (defun gnus-dired-mail-buffers ()
      "Return a list of active message buffers."
       (let (buffers)
        (save-current-buffer
         (dolist (buffer (buffer-list t))
	  (set-buffer buffer)
	  (when (and (derived-mode-p 'message-mode)
		(null message-sent-message-via))
	     (push (buffer-name buffer) buffers))))
        (nreverse buffers)))
     (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
))
#+end_src

** messages-are-flowing
#+begin_src emacs-lisp
(with-eval-after-load "message"
  (add-hook 'message-mode-hook 'messages-are-flowing-use-and-mark-hard-newlines))
#+end_src

* Major-modes
** paperless
#+begin_src emacs-lisp
(use-package paperless
  :config
   (setq paperless-capture-directory "~/texte/texteingang")
   (setq paperless-root-directory "~/"))
#+end_src

** calendar
*** org-gcal
#+begin_src emacs-lisp
(use-package org-gcal
  :config
  (setq org-gcal-auto-archive t)
  (setq org-gcal-down-days 365)
  (setq org-gcal-client-id "553301842275-clecdgmr7i8741e3ck5iltlgfk3qf79r.apps.googleusercontent.com")
  (setq org-gcal-client-secret "4zyEbm_F_BMuJsA7rZZmgFBm")
  (setq org-gcal-file-alist '(("jobangen@googlemail.com" . "~/Dropbox/db/org/calender.org")))
)

#+end_src
client-ID:
553301842275-clecdgmr7i8741e3ck5iltlgfk3qf79r.apps.googleusercontent.com 

secret/schlüssel
4zyEbm_F_BMuJsA7rZZmgFBm 


Kalender-ID: 3nh2s5l59kgkoshecpffpuapq8@group.calendar.google.com

** pdf-tools
#+begin_src emacs-lisp
(use-package pdf-tools
    :ensure t
    :config
     (pdf-tools-install)
     (eval-after-load 'org '(require 'org-pdfview))
     (add-to-list 'org-file-apps '("\\.pdf\\'" . org-pdfview-open))
     (add-to-list 'org-file-apps '("\\.pdf::\\([[:digit:]]+\\)\\'" . org-pdfview-open))
     (setq-default pdf-view-display-size 'fit-width)
     (bind-keys :map pdf-view-mode-map
     ("ad" . pdf-annot-delete)
     ("al" . pdf-annot-list-annotations)
     ("am" . pdf-annot-add-markup-annotation)
     ("ah" . pdf-annot-add-highlight-markup-annotation)
     ("aq" . pdf-annot-add-squiggly-markup-annotation)
     ("as" . pdf-annot-add-strikeout-markup-annotation)
     ("at" . pdf-annot-add-text-annotation)
     ("au" . pdf-annot-add-underline-markup-annotation)
     ("j"  . pdf-view-goto-page)
     ("s"  . pdf-occur))


(defun pdf-view--rotate (&optional counterclockwise-p page-p)
  "Rotate PDF 90 degrees.  Requires pdftk to work.\n
Clockwise rotation is the default; set COUNTERCLOCKWISE-P to
non-nil for the other direction.  Rotate the whole document by
default; set PAGE-P to non-nil to rotate only the current page.
\nWARNING: overwrites the original file, so be careful!"
  ;; error out when pdftk is not installed
  (if (null (executable-find "pdftk"))
      (error "Rotation requires pdftk")
    ;; only rotate in pdf-view-mode
    (when (eq major-mode 'pdf-view-mode)
      (let* ((rotate (if counterclockwise-p "left" "right"))
             (file   (format "\"%s\"" (pdf-view-buffer-file-name)))
             (page   (pdf-view-current-page))
             (pages  (cond ((not page-p)                        ; whole doc?
                            (format "1-end%s" rotate))
                           ((= page 1)                          ; first page?
                            (format "%d%s %d-end"
                                    page rotate (1+ page)))
                           ((= page (pdf-info-number-of-pages)) ; last page?
                            (format "1-%d %d%s"
                                    (1- page) page rotate))
                           (t                                   ; interior page?
                            (format "1-%d %d%s %d-end"
                                    (1- page) page rotate (1+ page))))))
        ;; empty string if it worked
        (if (string= "" (shell-command-to-string
                         (format (concat "pdftk %s cat %s "
                                         "output %s.NEW "
                                         "&& mv %s.NEW %s")
                                 file pages file file file)))
            (pdf-view-revert-buffer nil t)
          (error "Rotation error!"))))))

(defun pdf-view-rotate-clockwise (&optional arg)
  "Rotate PDF page 90 degrees clockwise.  With prefix ARG, rotate
entire document."
  (interactive "P")
  (pdf-view--rotate nil (not arg)))

(defun pdf-view-rotate-counterclockwise (&optional arg)
  "Rotate PDF page 90 degrees counterclockwise.  With prefix ARG,
rotate entire document."
  (interactive "P")
  (pdf-view--rotate :counterclockwise (not arg)))

)


(add-to-list 'org-file-apps '("\\.pdf\\'" . (lambda (file link) (org-pdfview-open link))))
#+end_src

** ess
#+begin_src emacs-lisp
(use-package ess
  :defer t
  :commands (R))
#+end_src

** haskell-mode
#+begin_src emacs-lisp
(use-package haskell-mode
  :defer t)
#+end_src

** csv-mode
#+begin_src emacs-lisp
(use-package csv-mode
  :defer t
  :config
   (setq csv-separators '("," ";"))
   (add-hook 'csv-mode-hook
          '(lambda () (csv-align-fields nil (buffer-end -1) (buffer-end +1))))
)
#+end_src

** dired
#+begin_src emacs-lisp
(setq dired-recursive-deletes 'always)
(setq dired-recursive-copies 'always)
(setq dired-dwim-target t)
(setq delete-by-moving-to-trash t
      trash-directory "~/.local/share/Trash")
(setq dired-listing-switches "--group-directories-first -alh1v")
(put 'dired-find-alternate-file 'disabled nil)

(add-hook 'dired-mode-hook 'dired-hide-details-mode)
;; auto refresh dired when file changes; from Ben Maughan
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+end_src

*** dired-subtree
#+begin_src emacs-lisp
(bind-key "i" 'dired-subtree-insert dired-mode-map)
(bind-key "I" 'dired-subtree-remove dired-mode-map)
#+end_src

*** dired-filter
#+begin_src emacs-lisp
(use-package dired-filter
  :config
  (add-hook 'dired-mode-hook 'dired-filter-group-mode t)
  (setq dired-filter-group-saved-groups
      '(("default"
        ("DIR"
         (directory))
        ("PDF"
         (extension . "pdf"))
        ("LaTeX"
         (extension "tex" "bib"))
        ("Text & Data"
         (extension "org" "txt" "doc" "docx" "csv" "odt"))
        ("Media"
         (extension "JPG" "jpg" "PNG" "png" "gif" "bmp"))
        ("Archives"
         (extension "zip" "rar" "gz" "bz2" "tar" "org_archive"))))))
#+end_src

*** peep-dired
#+begin_src emacs-lisp
;;preview files in dired
(use-package peep-dired
  :ensure t
  :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
  :bind (:map dired-mode-map
              ("P" . peep-dired)))
#+end_src

* Minor-modes
** abbrev-mode
#+begin_src emacs-lisp
(use-package abbrev
 :diminish abbrev-mode
 :config
 (progn 
  (setq save-abbrevs 'silently)
  (setq save-abbrevs t)
  (setq-default abbrev-mode t))
)
#+end_src

** bookmarks+
#+begin_src emacs-lisp
(use-package bookmark+
  :ensure t
  :bind ("C-<menu>" . bookmark-jump)
  :init
   (setq bookmark-default-file (expand-file-name (concat user-emacs-directory "bookmarks")))
   (setq bookmark-save-flag 1))
#+end_src

** engine-mode
#+begin_src emacs-lisp
(use-package engine-mode
  :ensure t
  :config
  (engine-mode t)
  (defengine google
  "http://www.google.de/search?ie=utf-8&oe=utf-8&q=%s")
  (defengine google-images
  "http://www.google.de/images?hl=en&source=hp&biw=1440&bih=795&gbv=2&aq=f&aqi=&aql=&oq=&q=%s")
  (defengine google-scholar
  "https://scholar.google.de/scholar?hl=de&q=%s")
  (defengine duckduckgo
  "https://duckduckgo.com/?q=%s")
  (defengine fu-katalog
  "http://aleph-www.ub.fu-berlin.de/F/?func=find-e&request=%s")
  (defengine jstor
  "http://www.jstor.org/action/doBasicSearch?acc=on&wc=on&fc=off&group=none&Query=%s")
  (defengine sowiport
  "http://sowiport.gesis.org/Search/Results?type=AllFields&lookfor=%s")
  (defengine pons-de-en
   "http://de.pons.com/übersetzung?l=deen&in=&lf=de&q=%s")
  (defengine youtube
   "http://www.youtube.com/results?aq=f&oq=&search_query=%s")
  (defengine wikipedia
   "http://www.wikipedia.org/search-redirect.php?language=de&go=Go&search=%s")
)
#+end_src

** hippie-expand
#+begin_src emacs-lisp
(use-package hippie-expand
  :bind ("M-<tab>" . hippie-expand)
  :init
   (setq hippie-expand-verbose t)

   (setq hippie-expand-try-functions-list
         '(yas-hippie-try-expand
   ;;        try-expand-all-abbrevs
   ;;        try-complete-file-name-partially
   ;;        try-complete-file-name
            try-expand-dabbrev
   ;;        try-expand-dabbrev-from-kill
            try-expand-dabbrev-all-buffers
   ;;        try-expand-list
   ;;        try-expand-line
   ;;        try-complete-lisp-symbol-partially
   ;;        try-complete-lisp-symbol
   ))
)
#+end_src

** projectile
#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :config
   (progn
     (projectile-global-mode)
     (setq projectile-completion-system 'ivy)
     (setq projectile-enable-caching t)
     (setq projectile-switch-project-action 'projectile-dired)))
#+end_src

#+begin_src emacs-lisp
(use-package counsel-projectile
  :config
    (counsel-projectile-on))
#+end_src

** smartparens 
#+begin_src emacs-lisp
(use-package smartparens
  :ensure t
  :diminish smartparens-mode
  :config
  (progn
    (require 'smartparens-config)
    (smartparens-global-mode t)
    (show-smartparens-global-mode t)))
(add-hook 'yas-before-expand-snippet-hook (lambda () (smartparens-mode -1)))
(add-hook 'yas-after-exit-snippet-hook (lambda () (smartparens-mode 1)))

(defvar sp-unicode-quotes-mode-map (make-keymap)
"Use the \" key for “”.")

(define-minor-mode sp-unicode-quotes-mode
"A minor mode that remaps the quote key to sp-pair “”" nil " sp-quote" 'sp-unicode-quotes-mode-map

(sp-pair "“" "”"))

(define-key sp-unicode-quotes-mode-map (kbd "\"") (kbd "“"))

(provide 'sp-unicode-quotes-mode)

#+end_src

** yasnippet
#+begin_src emacs-lisp
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode
  :config
  (progn
    (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
    (yas-global-mode 1)
    (setq require-final-newline nil)
;;    (bind-key "TAB" 'hippie-expand yas-minor-mode-map)
))
#+end_src
** epa-file
#+begin_src emacs-lisp
(use-package epa-file
  :config
    (epa-file-enable)
    ;; Symmetric Encryption.
    (setq epa-file-select-keys nil))
#+end_src

** keyfreq
#+begin_src emacs-lisp
(use-package keyfreq
  :config
  (setq keyfreq-excluded-commands
      '(backward-char
        delete-backward-char
        forward-char
        handle-switch-frame
        left-char
        left-word
        mouse-drag-region
        mouse-set-point
        mwheel-scroll
        next-line
        previous-line
        right-char
        right-word
        self-insert-command
        ;;isearch
        isearch-printing-char
        ;;org
        org-self-insert-command
        org-delete-backward-char
        org-return
        org-agenda-next-line
        org-agenda-previous-line
        org-ref-next-key
        ;;Ivy
        ivy-done
        ivy-next-line
        ivy-previous-line
        magit-invoke-popup-action
))
(keyfreq-mode 1)
(keyfreq-autosave-mode 1))
#+end_src

** pomodoro
#+begin_src emacs-lisp
(use-package pomodoro
  :load-path "~/.emacs.d/non-elpa/pomodoro")
#+end_src

** pomidor
#+begin_src emacs-lisp
(use-package pomidor
  :config
    (setq pomidor-sound-tick nil
          pomidor-sound-tack nil
          pomidor-sound-overwork nil)
    (setq alert-default-style 'libnotify)
 )
#+end_src

** rainbow-delimiters
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :disabled t)
#+end_src

* hydra
** hydra-setup
#+begin_src emacs-lisp
(use-package hydra
   :ensure t)
#+end_src

** hydra-time
#+begin_src emacs-lisp
(bind-key "C-<f11>" 'hydra-time/body)

(defhydra hydra-time (:hint nil)
"
^Clock^        ^ ^             ^Timer^                  ^Countdown^           ^Pomodoro
^-^-------------^-^----------╯╭-^-^------------------╯╭^-^----------------╯╭-^-^--------
_i_: in         _j_: goto       _ti_: in                _c_: countdown '25    _pi_: in
_l_: in-last    _s_: select     _tp_: pause/continue    ^ ^                   _po_: out
_o_: out        _d_: display    _ti_: insert            ^ ^                   _ps_: status
_q_: cancel     _r_: resolve    _tI_: insert item       ^ ^                   _pn_: next
" 
 ("c" org-timer-set-timer)
 ("d" org-clock-display)
 ("i" org-clock-in)
 ("j" org-clock-goto)
 ("l" org-clock-in-last)
 ("o" org-clock-out)
 ("q" org-clock-cancel)
 ("r" org-resolve-clocks)
 ("s" org-clock-select-task)
 ("ti" org-timer-start)
 ("to" org-timer-stop)
 ("tp" org-timer-pause-or-continue)
 ("ti" org-timer)
 ("tI" org-timer-item)
 ("pi" pomodoro)
 ("pn" pomodoro-skip-forward)
 ("po" pomodoro-stop)
 ("ps" pomodoro-status)
)
#+end_src

** hydra-modes
#+begin_src emacs-lisp
(bind-key "<f1>" 'hydra-modes/body)
(defhydra hydra-modes (:color blue :columns 3)
"Modes"
("a" auto-fill-mode "auto-fill-mode")
("b" bbdb "bbdb")
("d" deft "deft")
("f" flyspell-mode "flyspell")
("g" gnus "gnus")
("i" interleave "interleave")
("l" paperless "paperless")
("p" pdf-tools-install "pdf-tools")
("P" pandoc-mode "pandoc")
("r" rainbow-delimiters-mode "rainbow-delimiters")
("v" visual-line-mode "visual-line")
("w" writegood-mode "writegood"))
#+end_src

** hydra-projectile
#+begin_src emacs-lisp
(bind-key "C-c P" 'hydra-projectile/body)
(bind-key "C-ä P" 'hydra-projectile/body)
(defhydra hydra-projectile (:color teal
                            :hint nil)
  "
  PROJECTILE: %(projectile-project-root)

 ^Find File^            ^Search^            ^Buffers^                ^Cache
------------------------------------------------------------------------------------------
 _ff_: file             _a_: counsel-ag        _i_: Ibuffer             _c_: cache clear
 _fc_: file curr dir    _A_: ag                _b_: switch to buffer    _x_: remove known project
 _fd_: file dwim        _g_: counsel-grep      _k_: Kill all buffers    _X_: cleanup non-existing
  _r_: recent file      _G_: grep                                     ^^_z_: cache current
  _d_: dir              _o_: multi-occur

"
  ("a"   counsel-ag)
  ("A"   projectile-ag)
  ("b"   projectile-switch-to-buffer)
  ("c"   projectile-invalidate-cache)
  ("d"   projectile-find-dir)
  ("g"   counsel-grep)
  ("G"   projectile-grep)
  ("ff"  projectile-find-file)
  ("fc"  projectile-find-file-in-directory)
  ("fd"  projectile-find-file-dwim)
  ("i"   projectile-ibuffer)
  ("k"   projectile-kill-buffers)
  ("o"   projectile-multi-occur)
  ("p"   projectile-switch-project "switch project")
  ("r"   projectile-recentf)
  ("x"   projectile-remove-known-project)
  ("X"   projectile-cleanup-known-projects)
  ("z"   projectile-cache-current-file)
  ("q"   nil "cancel" :color blue)
)
#+end_src

** hydra-window
#+begin_src emacs-lisp
(bind-key "C-c w" 'hydra-window/body)
(defhydra hydra-window (:hint nil
                        :color red)
 "
 Window-move
----------------------------------------------------------------------------
^      _<up>_           ^_x_: split-horz     _a_: ace-window    _G_: mode       _b_: balance
_<left>_    _<right>_    _y_: split-vert     _s_: ace-swap      _g_: refresh    _+_: enlarge
^     _<down>_          ^_d_: ace-delete                      ^^_t_: toggle     _-_: shrink
                     ^^^^_o_: delete-other                    ^^_j_: adjust

"
  ("+" enlarge-window-horizontally)
  ("-" shrink-window-horizontally)
  ("<left>"  windmove-left)
  ("<down>"  windmove-down)
  ("<up>"    windmove-up)
  ("<right>" windmove-right)
  ("a" ace-window)
  ("b" balance-windows)
  ("d" ace-delete-window)
  ("g" golden-ratio)
  ("G" golden-ratio-mode)
  ("j" golden-ratio-adjust)
  ("o" delete-other-windows :exit t)
  ("q" nil "cancel" :color blue)
  ("s" ace-swap-window)
  ("t" golden-ratio-toggle-widescreen)
  ("x" (lambda ()
               (interactive)
               (split-window-right)
               (windmove-right)))
  ("y" (lambda ()
               (interactive)
               (split-window-below)
               (windmove-down))))

#+end_src

** hydra-text
#+begin_src emacs-lisp
  (bind-key "C-c t" 'hydra-text/body)
  (bind-key "C-ä t" 'hydra-text/body)
  (defhydra hydra-text (:hint nil
                        :color red
                        :columns 2)
  "Text"
  ("p" previous-line "previous-line")
  ("n" next-line "next-line")
  ("c" count-words "count")
  ("j" join-line "join-line")
  ("m" char-menu "char-menu")
  ("s" sort-lines "sort-lines")
  ("t" zettelkasten-insert-tags "Tags")
  ("u" my/uniquify-all-lines-region "uniquify")
  ("q" nil "cancel" :exit t))
#+end_src
** hydra-git
#+begin_src emacs-lisp
(bind-key "C-x G" 'hydra-git/body)
(defhydra hydra-git (:color blue)
"
Git
"
("g" magit-status "magit-status")
("m" git-messenger:popup-message "messenger")
("w" git-wip-mode "wip")
("t" git-timemachine "timemachine")
("T" git-wip-timemachine "wip-timemachine")
)
#+end_src

** hydra-spellcheck
#+begin_src emacs-lisp
(bind-key "C-c S" 'hydra-spellcheck/body)
(defhydra hydra-spellcheck (:color red :columns 3)
"Flyspell"
("b" flyspell-buffer "buffer")
("c" ispell-word "ispell word")
("d" ispell-change-dictionary "change dictionary")
("i" ispell-buffer "ispell buffer")
("m" flyspell-mode "mode")
("n" flyspell-check-next-highlighted-word "next")
("p" flyspell-check-previous-highlighted-word "previous")
)
#+end_src

** hydra-engine+
#+begin_src emacs-lisp
(bind-key "C-c e" 'hydra-engine+/body)
(defhydra hydra-engine+ (:hint nil
                         :color blue)
"
^Search^          ^Biblio^           ^Lang^
^-^---------------^-^----------------^-^-----------------
_g_: google       _bS_: scholar      _t_: translate
_i_: images       _bf_: fu-katalog   _s_: synonyms
_d_: duckduckgo   _bj_: jstor        _c_: - change lang
_w_: wikipedia    _bs_: sowiport
_y_: youtube      _bb_: bibtex
"
("bb" gscholar-bibtex)
("bf" engine/search-fu-katalog)
("bj" engine/search-jstor)
("bs" engine/search-sowiport)
("bS" engine/search-google-scholar)
("c" www-synonyms-change-lang)
("g" engine/search-google)
("i" engine/search-google-images)
("d" engine/search-duckduckgo)
("y" engine/search-youtube)
("p" engine/search-pons-de-en)
("s" www-synonyms-insert-synonym)
("t" google-translate-smooth-translate)
("w" engine/search-wikipedia)
) 
#+end_src

* zettelkasten
** zettelkasten defun
#+begin_src emacs-lisp
(defun zettelkasten-combine-zettel ()
  (shell-command "cat ~/Dropbox/db/zk/*.txt > ~/Dropbox/db/stats/zettelkasten/zettel-combined.txt"))


(defvar zettelkasten-tags-values)

(defun zettelkasten-parse-tags-values ()
  (interactive)
  (setq zettelkasten-tags-values (zettelkasten-collect-tags-values)))

(defun zettelkasten-collect-tags-values (&optional regexp)
  "Collect values in keywords fields of all BibTeX entries.
Maybe restrict the values to those matching REGEXP. Keywords may be phrases
separated by commas. Multiple spaces or newlines within a keyword will be
removed before collection."
  (save-excursion
    (goto-char (point-min))
    (let (zk-tags kstring)
      (while (re-search-forward "^tags:\\s-*\\(.*\\),$" nil t)
        ;; TWS - remove newlines/multiple spaces:
    (setq kstring (replace-regexp-in-string "[ \t\n]+" " "
          (match-string-no-properties 1)))
	(mapc
	 (lambda (v)
	   (if regexp (if (string-match regexp v)
			  (add-to-list 'zk-tags v t))
	     (add-to-list 'zk-tags v t)))
          (split-string kstring ",[ \n]*\\|{\\|}" t)))
      zk-tags)))

(defun zettelkasten-parse-values-combined ()
  (interactive)
  (zettelkasten-combine-zettel)
  (find-file (expand-file-name (concat db-dir "stats/zettelkasten/zettel-combined.txt")))
  (zettelkasten-parse-tags-values))

(defun zettelkasten-tangle-combined ()
  (org-babel-tangle-file "~/Dropbox/db/stats/zettelkasten/zettel-combined.txt"))

(defun zettelkasten-combine-tangle-combined ()
  (interactive)
  (zettelkasten-combine-zettel)
  (zettelkasten-tangle-combined))


(defun zettelkasten-update-tags-tangle ()
    (interactive)
    (zettelkasten-combine-zettel)
    (zettelkasten-parse-values-combined)
    (zettelkasten-tangle-combined))

(add-hook 'after-init-hook 'zettelkasten-update-tags-tangle)


(defun zettelkasten-insert-tags (&optional arg)
  "Make a keywords field.
If ARG is nil, ask for each keyword and offer completion over
keywords that are already available in the buffer.  Inserting
the empty string will quit the prompt. If the keyword is not already
present in the buffer, it will be added to the local variable
bu-keywords-values. Note that if you use ido-ubiquitous, the value of
  `ido-ubiquitous-enable-old-style-default' is temporarily set to t within
the body of this command."
  (interactive "P")
  (let ((elist (save-excursion))
        append)
    (if (assoc "zk-tags" elist)
	 (progn (setq append t)))
    (unless arg
      (let ((cnt 0)
            k)
	(while (and (setq k (completing-read
                             "Tags (RET to quit): " zettelkasten-tags-values nil))
		    (not (equal k "")))
	  (when append (insert ", ")
                (setq append nil))
	  (setq cnt (1+ cnt))
	  (insert (format "%s%s" (if (> cnt 1) ", " "") k))
          (add-to-list 'zettelkasten-tags-values k))))))


(defun zettelkasten-insert-regex ()
  (interactive)
  (insert "\\s-\\([a-z]*\\|[0-9]*\\)~")
  (goto-char 22))

(defface zettelkasten-id-face `((t (:background "#e0e0e0")))  "Zettelkasten Ids")
(defface zettelkasten-lvl1-face `((t (:background "#6880c7")))  "Zettelkasten Level 1")
(defface zettelkasten-lvl2-face `((t (:background "#778ccc")))  "Zettelkasten Level 2")
(defface zettelkasten-lvl3-face `((t (:background "#8699d2")))  "Zettelkasten Level 3")

(defun zettelkasten-markup ()
   (highlight-regexp "\\s-[0-9]*~" 'zettelkasten-lvl1-face)
   (highlight-regexp "[0-9]*-[0-9]*~" 'zettelkasten-lvl2-face)
   (highlight-regexp "[0-9]*-[0-9]*[a-z]*~" 'zettelkasten-lvl3-face)
   (highlight-regexp "\[0-9a-z\\-\]*~" 'zettelkasten-id-face))

(add-hook 'dired-mode-hook 'zettelkasten-markup)

;;(defun zettelkasten-finish-zettel (reverse)
;;   (interactive "*P\nr")
;;   (goto-char (point-min))
;;   (search-forward-regexp "tags: " nil t)
;;   (search-forward-regexp ", " nil t)
;;   (set-mark (point))
;;   (move-end-of-line 1)
;;   (search-backward-regexp "§" nil t)
;;   (search-forward-regexp ", " nil t)
;;   (sort-regexp-fields reverse "[a-zA-Z0-9->§]+" "\\&" nil nil)
;;)

(defun zettelkasten-mark-tags ()
   (interactive)
   (goto-char (point-min))
   (search-forward-regexp "tags: " nil t)
   (move-end-of-line 1)
   (search-backward-regexp "§" nil t)
   (search-forward-regexp ", " nil t)
   (set-mark (point))
   (move-end-of-line 1)
)
#+end_src
** deft
#+begin_src emacs-lisp
(use-package deft
  :config
  (setq deft-directory "~/Dropbox/db/zk")

  (bind-key "C-h" 'deft-filter-decrement deft-mode-map)
  (bind-key "C-w" 'deft-filter-decrement-word deft-mode-map)
)
#+end_src

** Remembrance Agent
#+begin_src emacs-lisp
(use-package remem
  :load-path "~/.emacs.d/non-elpa/remembrance-agent"
  :config
   (setq remem-database-dir "~/.custom-temp/ra-index")
   (setq remem-scopes-list '(("zettelkasten" 5 2 500)
                             ("texte" 5 2 500)))
   (setq remem-print-exact-relevance-p t)
   (setq remem-load-original-suggestion t)
   (setq remem-log-p t)
   (setq remem-logfile (expand-file-name "~/.custom-temp/.remem-log-file"))

   (setq remem-format-default
     '((0 2 (field 0 mouse-face remem-hilite2) nil)                   ; Number
       (1 2 (face remem-even field 1) nil)                            ; sim
       (9 3 (face remem-odd field 9 mouse-face remem-hilite) nil)     ; person
       (8 25 (face remem-even field 8 mouse-face remem-hilite) nil)   ; subject
       (28 50 (face remem-odd field 28 mouse-face remem-hilite) nil))); keywords
)
#+end_src

** org-brain
#+begin_src emacs-lisp
(use-package org-brain
  :config
    (require 'org-brain)
    (setq org-brain-path (expand-file-name zettelkasten-dir))
    (setq org-brain-children-headline-default-name "Links & Files")
    (setq org-brain-children-tag-default-name "children")
    (setq org-brain-files-extension "txt")
    (org-brain-activate-cache-saving))
#+end_src

** zettelkasten-hydra
#+begin_src emacs-lisp
(bind-key "C-c z" 'hydra-zettelkasten/body)
(defhydra hydra-zettelkasten (:hint nil
                              :color red
                              :columns 2)
"Zettelkasten"
("l" org-brain-insert-link "brain-link")
("m" zettelkasten-mark-tags "mark-tags")
("s" sort-symbols "sort-symbols")
("v" org-brain-visualize "visualize")
)
#+end_src


* defun
** my/insert-date
#+begin_src emacs-lisp
(defun my/insert-date (prefix)
  "Insert the current date ISO-format; With prefix-argument: insert current date ISO-format with time. With two prefix arguments, insert date."
    (interactive "P")
    (let ((format (cond
                   ((not prefix) "%Y-%m-%d")
                   ((equal prefix '(4)) "%Y-%m-%d-%H%M")
                   ((equal prefix '(16)) "%d.%m.%Y")
;;                   ((equal prefix '(??)) "%A, %d. %B %Y")
))
          (system-time-locale "de_DE"))
      (insert (format-time-string format))))
(bind-key "C-c d" 'my/insert-date)
#+end_src

** smarter-move-beginning-of-line
Funktioniert noch nicht richtig..oder?
#+begin_src emacs-lisp
;; from http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/
;; über Sacha Chua
(defun smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;;(bind-key "C-a" 'smarter-move-beginning-of-line)
;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'smarter-move-beginning-of-line)
#+end_src

** my/html-to-german
#+begin_src emacs-lisp
(defun my/html-to-german ()
"Replace HTML token with german umlauts in current buffer"
   (interactive)
      (save-excursion
	(goto-char (point-min))
	(perform-replace "&Auml;" "Ä" nil nil nil)
	(goto-char (point-min))
	(perform-replace "&auml;" "ä" nil nil nil)
	(goto-char (point-min))
	(perform-replace "&Ouml;" "Ö" nil nil nil)
	(goto-char (point-min))
	(perform-replace "&ouml;" "ö" nil nil nil)
	(goto-char (point-min))
	(perform-replace "&Uuml;" "Ü" nil nil nil)
	(goto-char (point-min))
	(perform-replace "&uuml;" "ü" nil nil nil)
	(goto-char (point-min))
	(perform-replace "&szlig;" "ß" nil nil nil)))
#+end_src

** my/uniquify-all-lines
#+begin_src emacs-lisp
(defun my/uniquify-all-lines-region (start end)
  "Find duplicate lines in region START to END keeping first occurrence."
  (interactive "*r")
  (save-excursion
    (let ((end (copy-marker end)))
      (while
          (progn
            (goto-char start)
            (re-search-forward "^\\(.*\\)\n\\(\\(.*\n\\)*\\)\\1\n" end t))
        (replace-match "\\1\n\\2")))))

(defun my/uniquify-all-lines-buffer ()
  "Delete duplicate lines in buffer and keep first occurrence."
  (interactive "*")
  (my/uniquify-all-lines-region (point-min) (point-max)))
#+end_src

** my/vsplit & my/hsplit
#+begin_src emacs-lisp
  (defun my/vsplit-last-buffer (prefix)
    "Split the window vertically and display the previous buffer."
    (interactive "p")
    (split-window-vertically)
    (other-window 1 nil)
    (if (= prefix 1)
      (switch-to-next-buffer)))

  (defun my/hsplit-last-buffer (prefix)
    "Split the window horizontally and display the previous buffer."
    (interactive "p")
    (split-window-horizontally)
    (other-window 1 nil)
    (if (= prefix 1) (switch-to-next-buffer)))

  (bind-key "C-x 2" 'my/vsplit-last-buffer)
  (bind-key "C-x 3" 'my/hsplit-last-buffer)
#+end_src

http://mbork.pl/2017-02-26_other-window-or-switch-buffer
#+begin_src emacs-lisp
  (defun job/other-window-or-my/hsplit-last-buffer (prefix)
    "Call `other-window' if more than one window is visible, create
  and swith otherwise"
    (interactive "p")
    (if (one-window-p)
	    (my/hsplit-last-buffer prefix)
	  (other-window 1)))

  (bind-key "C-t" 'job/other-window-or-my/hsplit-last-buffer)
#+end_src

** frequencies
https://emacs.stackexchange.com/questions/13514/how-to-obtain-the-statistic-of-the-the-frequency-of-words-in-a-buffer
#+begin_src emacs-lisp
(defvar word-frequency-table (make-hash-table :test 'equal :size 128))

(defvar word-frequency-buffer "*zk-tags*"
  "Buffer where frequencies are displayed.")

(defun word-frequency-incr (word)
  (puthash word (1+ (gethash word word-frequency-table 0)) word-frequency-table))

(defun word-frequency-list (&optional reverse limit)
  "Returns a cons which car is sum of times any word was used
and cdr is a list of (word . count) pairs.  If REVERSE is nil
sorts it starting from the most used word; if it is 'no-sort
the list is not sorted; if it is non-nil and not 'no-sort sorts
it from the least used words.  If LIMIT is positive number
only words which were used more then LIMIT times will be
added.  If it is negative number only words which were used
less then -LIMIT times will be added."
  (let (l (sum 0))
    (maphash
     (cond
      ((or (not (numberp limit)) (= limit 0))
       (lambda (k v) (setq l (cons (cons k v) l) sum (+ sum v))))
      ((= limit -1) (lambda (k v) (setq sum (+ sum v))))
      ((< limit 0)
       (setq limit (- limit))
       (lambda (k v) (setq sum (+ sum v))
         (if (< v limit) (setq l (cons (cons k v) l)))))
      (t
       (lambda (k v) (setq sum (+ sum v))
         (if (> v limit) (setq l (cons (cons k v) l))))))
     word-frequency-table)
    (cons sum
          (cond
           ((equal reverse 'no-sort) l)
           (reverse (sort l (lambda (a b) (< (cdr a) (cdr b)))))
           (t       (sort l (lambda (a b) (> (cdr a) (cdr b)))))))))

(defun word-frequency-string (&optional reverse limit func)
  "Returns formatted string with word usage statistics.

If FUNC is nil each line contains number of times word was
called and the word; if it is t percentage usage is added in
the middle; if it is 'raw each line will contain number an
word separated by single line (with no formatting) otherwise
FUNC must be a function returning a string which will be called
for each entry with three arguments: number of times word was
called, percentage usage and the word.

See `word-frequency-list' for description of REVERSE and LIMIT
arguments."
  (let* ((list (word-frequency-list reverse)) (sum (car list)))
    (mapconcat
     (cond
      ((not func) (lambda (e) (format "%7d, %s\n" (cdr e) (car e))))
      ((equal func t)
       (lambda (e) (format "%7d, %6.2f%%, %03d, %s\n"
                           (cdr e) 
               (/ (* 1e2 (cdr e)) sum) 
               (length (car e))
               (car e))))
      ((equal func 'raw) (lambda (e) (format "%d %s\n" (cdr e) (car e))))
      (t (lambda (e) (funcall func (cdr e) (/ (* 1e2 (cdr e)) sum) (car e)))))
     (cdr list) "")))

(defun word-frequency (&optional where reverse limit func)
  "Formats word usage statistics using
`word-frequency-string' function (see for description of
REVERSE, LIMIT and FUNC arguments) and:
- if WHERE is nil inserts it in th e
  or displays it in echo area if possible; else
- if WHERE is t inserts it in the current buffer; else
- if WHERE is an empty string inserts it into
  `word-frequency-buffer' buffer; else
- inserts it into buffer WHERE.

When called interactively behaves as if WHERE and LIMIT were nil,
FUNC was t and:
- with no prefix argument - REVERSE was nil;
- with universal or positive prefix arument - REVERSE was t;
- with negative prefix argument - REVERSE was 'no-sort."

  (interactive (list nil
                     (cond
                      ((not current-prefix-arg) nil)
                      ((> (prefix-numeric-value current-prefix-arg) 0))
                      (t 'no-sort))
                     nil t))
  (clrhash word-frequency-table)
  (word-frequency-process-buffer)
  (cond
   ((not where)
    (display-message-or-buffer (word-frequency-string reverse limit func)
                               word-frequency-buffer))
   ((equal where t)
    (insert (word-frequency-string reverse limit func)))
   (t
    (display-buffer
     (if (and (stringp where) (string= where ""))
         word-frequency-buffer where)
     (word-frequency-string reverse limit func)))))

(defun word-frequency-process-buffer ()
  (interactive)
  (let ((buffer (current-buffer))
        bounds
        beg
        end
        word)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "[§#][^,]*" nil t)
;;    (while (forward-word 1)
        (word-frequency-incr (downcase (match-string 0)))
;;      (setq bounds (bounds-of-thing-at-point 'word))
;;      (setq beg (car bounds))
;;      (setq end (cdr bounds))
;;      (setq word (downcase (buffer-substring-no-properties beg end)))
;;      (word-frequency-incr word)
        ))))
#+end_src
** my/unfill-paragraph
http://mbork.pl/2015-11-14_A_simple_unfilling_function
#+begin_src emacs-lisp
(defun my/unfill-region (begin end)
  "Change isolated newlines in region into spaces."
  (interactive (if (use-region-p)
		   (list (region-beginning)
			 (region-end))
		 (list nil nil)))
  (save-restriction
    (narrow-to-region (or begin (point-min))
		      (or end (point-max)))
    (goto-char (point-min))
    (while (search-forward "\n" nil t)
      (if (eq (char-after) ?\n)
	  (skip-chars-forward "\n")
	(delete-char -1)
	(insert ?\s)))))
#+end_src
** my/random-todo
https://gist.github.com/tonyday567/4343164
#+begin_src emacs-lisp
(defun my/org-random-entry (&optional arg)
  "Select and goto a random todo item from the global agenda"
  (interactive "P")
  (if org-agenda-overriding-arguments
      (setq arg org-agenda-overriding-arguments))
  (if (and (stringp arg) (not (string-match "\\S-" arg))) (setq arg nil))
  (let* ((today (org-today))
         (date (calendar-gregorian-from-absolute today))
         (kwds org-todo-keywords-for-agenda)
         (lucky-entry nil)
         (completion-ignore-case t)
         (org-agenda-buffer (when (buffer-live-p org-agenda-buffer)
                              org-agenda-buffer))
         (org-select-this-todo-keyword
          (if (stringp arg) arg
            (and arg (integerp arg) (> arg 0)
                 (nth (1- arg) kwds))))
         rtn rtnall files file pos marker buffer)
    (when (equal arg '(4))
      (setq org-select-this-todo-keyword
            (org-icompleting-read "Keyword (or KWD1|K2D2|...): "
                                  (mapcar 'list kwds) nil nil)))
    (and (equal 0 arg) (setq org-select-this-todo-keyword nil))
    (catch 'exit
      (org-compile-prefix-format 'todo)
      (org-set-sorting-strategy 'todo)
      (setq files (org-agenda-files nil 'ifmode)
            rtnall nil)
      (while (setq file (pop files))
        (catch 'nextfile
          (org-check-agenda-file file)
          (setq rtn (org-agenda-get-day-entries file date :todo))
          (setq rtnall (append rtnall rtn))))

      (when rtnall
        (setq lucky-entry
              (nth (random
                    (safe-length
                     (setq entries rtnall)))
                   entries))

        (setq marker (or (get-text-property 0 'org-marker lucky-entry)
                         (org-agenda-error)))
        (setq buffer (marker-buffer marker))
        (setq pos (marker-position marker))
        (org-pop-to-buffer-same-window buffer)
        (widen)
        (goto-char pos)
        (when (derived-mode-p 'org-mode)
          (org-show-context 'agenda)
          (save-excursion
            (and (outline-next-heading)
                 (org-flag-heading nil))) ; show the next heading
          (when (outline-invisible-p)
            (show-entry))                 ; display invisible text
          (run-hooks 'org-agenda-after-show-hook))))))
#+end_src

** pdf-extract - x
;; modified from https://github.com/politza/pdf-tools/pull/133 
#+begin_src emacs-lisp
(defun mwp/pdf-multi-extract (sources)
  "Helper function to print highlighted text from a list of pdf's, with one org header per pdf, 
and links back to page of highlight."
  (let (
        (output ""))
    (dolist (thispdf sources)
      (setq output (concat output (pdf-annot-markups-as-org-text thispdf nil level ))))
    (princ output))
  )

;; this is stolen from https://github.com/pinguim06/pdf-tools/commit/22629c746878f4e554d4e530306f3433d594a654
(defun pdf-annot-edges-to-region (edges)
  "Attempt to get 4-entry region \(LEFT TOP RIGHT BOTTOM\) from several edges.
We need this to import annotations and to get marked-up text, because annotations
are referenced by its edges, but functions for these tasks need region."

  (let ((left0 (nth 0 (car edges)))
        (top0 (nth 1 (car edges)))
        (bottom0 (nth 3 (car edges)))
        (top1 (nth 1 (car (last edges))))
        (right1 (nth 2 (car (last edges))))
        (bottom1 (nth 3 (car (last edges))))
        (n (safe-length edges)))
    ;; we try to guess the line height to move
    ;; the region away from the boundary and
    ;; avoid double lines
    (list left0
          (+ top0 (/ (- bottom0 top0) 2))
          right1
          (- bottom1 (/ (- bottom1 top1) 2 )))))

(defun pdf-annot-markups-as-org-text (pdfpath &optional title level)
  "Acquire highligh annotations as text, and return as org-heading"

  (interactive "fPath to PDF: ")  
  (let* ((outputstring "") ;; the text to be returned
         (title (or title (replace-regexp-in-string "-" " " (file-name-base pdfpath ))))
         (level (or level (1+ (org-current-level)))) ;; I guess if we're not in an org-buffer this will fail
         (levelstring (make-string level ?*)) ;; set headline to proper level
         (annots (sort (pdf-info-getannots nil pdfpath)  ;; get and sort all annots
                       'pdf-annot-compare-annotations))
         )
    ;; create the header
    (setq outputstring (concat levelstring " Quotes From " title "\n\n")) ;; create heading

    ;; extract text
    (mapc
     (lambda (annot) ;; traverse all annotations
       (if (eq 'highlight (assoc-default 'type annot))
           (let* ((page (assoc-default 'page annot))
                  ;; use pdf-annot-edges-to-region to get correct boundaries of highlight
                  (real-edges (pdf-annot-edges-to-region
                               (pdf-annot-get annot 'markup-edges)))
                  (text (or (assoc-default 'subject annot) (assoc-default 'content annot)
                            (replace-regexp-in-string "\n" " " (pdf-info-gettext page real-edges nil pdfpath)
                                                      ) ))

                  (height (nth 1 real-edges)) ;; distance down the page
                  ;; use pdfview link directly to page number
                  (linktext (concat "[[pdfview:" pdfpath "::" (number-to-string page) 
                                    "++" (number-to-string height) "][" title  "]]" ))
                  )
             (setq outputstring (concat outputstring text " ("
                                        linktext ", " (number-to-string page) ")\n\n"))
             )))
     annots)
    outputstring ;; return the header
    )
  )
#+end_src

** my/bibtex-to-biblatex
#+begin_src emacs-lisp
(defun my/bibtex-to-biblatex ()
    (interactive)
    (goto-char 1)
       (while (search-forward-regexp "{[a-z0-9]*,$" nil t) 
          (replace-match "{," t nil))
       (while (search-forward-regexp "^  journal" nil t) 
          (replace-match "  journaltitle" t nil))
       (while (search-forward-regexp "^  year" nil t) 
          (replace-match "  date" t nil))
       (while (search-forward-regexp "^}$" nil t) 
          (replace-match "  timestamp={},
    keywords={},
  }" t nil))
       (while (search-forward-regexp "{\\\"a}" nil t) 
          (replace-match "ä" t nil))
       (while (search-forward-regexp "{\\\"u}" nil t) 
          (replace-match "ü" t nil))
   )


#+end_src

** my/keywords
#+begin_src emacs-lisp
(defun my/keyword ()
  (interactive)
  (beginning-of-line)
  (insert "§")
  (join-line)
  (insert ";")
)
#+end_src

** my/find-file-as-sudo
#+begin_src emacs-lisp
(defun my/find-file-as-sudo ()
  (interactive)
  (let ((file-name (buffer-file-name)))
    (when file-name
      (find-alternate-file (concat "/sudo::" file-name)))))
(bind-key "C-x C-v" 'my/find-file-as-sudo)
#+end_src

** my/ora-dired-rsync
[[gnus:nntp+news.gwene.org:gwene.org.emacsen.planet#x1-TbJMrYXpc6how8ft1npn6gGsHDg@gwene.org][Email from post@gwene.org: (or emacs: Using rsync in dire]]
#+begin_src emacs-lisp
(defun my/ora-dired-rsync (dest)
  (interactive
   (list
    (expand-file-name
     (read-file-name
      "Rsync to:"
      (dired-dwim-target-directory)))))
  ;; store all selected files into "files" list
  (let ((files (dired-get-marked-files
                nil current-prefix-arg))
        ;; the rsync command
        (tmtxt/rsync-command
         "rsync -arvz --progress "))
    ;; add all selected file names as arguments
    ;; to the rsync command
    (dolist (file files)
      (setq tmtxt/rsync-command
            (concat tmtxt/rsync-command
                    (shell-quote-argument file)
                    " ")))
    ;; append the destination
    (setq tmtxt/rsync-command
          (concat tmtxt/rsync-command
                  (shell-quote-argument dest)))
    ;; run the async shell command
    (async-shell-command tmtxt/rsync-command "*rsync*")
    ;; finally, switch to that window
    (other-window 1)))

(define-key dired-mode-map "Y" 'my/ora-dired-rsync)

#+end_src
** my/move-file-here
http://pragmaticemacs.com/emacs/quickly-move-a-file-to-the-current-directory/
#+begin_src emacs-lisp
(require 'dash)
(require 'swiper)

;; start directory
(defvar my/move-file-here-start-dir (expand-file-name "~/Downloads"))

(defun my/move-file-here ()
  "Move file from somewhere else to here.
The file is taken from a start directory set by `my/move-file-here-start-dir' and moved to the current directory if invoked in dired, or else the directory containing current buffer. The user is presented with a list of files in the start directory, from which to select the file to move, sorted by most recent first."
  (interactive)
  (let (file-list target-dir file-list-sorted start-file start-file-full)
    ;; clean directories from list but keep times
    (setq file-list
          (-remove (lambda (x) (nth 1 x))
                   (directory-files-and-attributes my/move-file-here-start-dir)))

    ;; get target directory
    ;; http://ergoemacs.org/emacs/emacs_copy_file_path.html
    (setq target-dir
          (if (equal major-mode 'dired-mode)
              (expand-file-name default-directory)
            (if (null (buffer-file-name))
                (user-error "ERROR: current buffer is not associated with a file.")
              (file-name-directory (buffer-file-name)))))

  ;; sort list by most recent
  ;;http://stackoverflow.com/questions/26514437/emacs-sort-list-of-directories-files-by-modification-date
  (setq file-list-sorted
        (mapcar #'car
                (sort file-list
                      #'(lambda (x y) (time-less-p (nth 6 y) (nth 6 x))))))

  ;; use ivy to select start-file
  (setq start-file (ivy-read
                    (concat "Move selected file to " target-dir ":")
                    file-list-sorted
                    :re-builder #'ivy--regex
                    :sort nil
                    :initial-input nil))

  ;; add full path to start file and end-file
  (setq start-file-full
        (expand-file-name start-file my/move-file-here-start-dir))
  (setq end-file
        (expand-file-name (file-name-nondirectory start-file) target-dir))
  (rename-file start-file-full end-file)
  (message "moved %s to %s" start-file-full end-file)))
#+end_src
** my/just-one-space-in-region
#+begin_src emacs-lisp
(defun my/just-one-space-in-region (beg end)
  "replace all whitespace in the region with single spaces"
  (interactive "r")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (while (re-search-forward "\\s-+" nil t)
        (replace-match " ")))))
#+end_src

** sort-words
https://www.emacswiki.org/emacs/SortWords
#+begin_src emacs-lisp
(defun sort-words (reverse beg end)
 "Sort words in region alphabetically, in REVERSE if negative.
  Prefixed with negative \\[universal-argument], sorts in reverse.

  The variable `sort-fold-case' determines whether alphabetic case
  affects the sort order.

  See `sort-regexp-fields'."
    (interactive "*P\nr")
    (sort-regexp-fields reverse "\\w+" "\\&" beg end))
#+end_src
** sort-symbols
#+begin_src emacs-lisp
(defun sort-symbols (reverse beg end)
  "Sort symbols in region alphabetically, in REVERSE if negative.
See `sort-words'."
  (interactive "*P\nr")
  (sort-regexp-fields reverse "\\(\\sw\\|\\s_\\)+" "\\&" beg end))
#+end_src
** gnuplot-defun
#+begin_src emacs-lisp
(defun my/gnuplot-electricity ()
  (interactive)
  (shell-command "source ~/script/electricity-calc.sh")
  (shell-command "gnuplot -persist ~/Dropbox/db/plot/electricity.plot"))

(defun my/gnuplot-org-entries ()
  (interactive)
  (my/org-clock-csv-write-calc)
  (shell-command "gnuplot -persist ~/Dropbox/db/stats/org-entries.plot"))
#+end_src

** narrow-or-widen-dwim
http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html
#+begin_src emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first. Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (define-key LaTeX-mode-map "\C-xn"
                nil)))
#+end_src

** my/berlinantiquariat-bill-format
#+begin_src emacs-lisp
(defun my/berlinantiquariat-bill-format ()
   (interactive)
   (goto-char (point-min))
   (while (search-forward-regexp "\\\\textit" nil t)
     (replace-match "" t nil))
   (goto-char (point-min))
   (while (search-forward-regexp "{\\[" nil t)
     (replace-match "" t nil))
   (goto-char (point-min))
   (while (search-forward-regexp "\\]}" nil t)
     (replace-match "" t nil))
   (goto-char (point-min))
   (while (search-forward-regexp "\"" nil t)
     (replace-match "" t nil))
   (goto-char (point-min))
   (while (search-forward-regexp "€" nil t)
     (replace-match "\\\\EURdig" t nil))
)
#+end_src
** my/pdfgrep
#+begin_src emacs-lisp
(defun pdfgrep-default-command ()
 "pdfgrep -i -H -n TERM  ~/texte/*.pdf")

(defun my/pdfgrep (command-args)
  ""
  (interactive
   (progn
     (let ((default (pdfgrep-default-command)))
       (list (read-shell-command "Run grep (like this): "
                                 (if current-prefix-arg "pdfgrep -i -H -n")
                                 'grep-history
                                 (if current-prefix-arg default))))))

  ;; Setting process-setup-function makes exit-message-function work
  ;; even when async processes aren't supported.
  (compilation-start (if (and grep-use-null-device null-device)
			 (concat command-args " " null-device)
		       command-args)
		     'grep-mode))
#+end_src
** my/move-file
http://zck.me/emacs-move-file
#+begin_src emacs-lisp
(defun my/move-file (new-location)
  "Write this file to NEW-LOCATION, and delete the old one."
  (interactive (list (if buffer-file-name
                         (read-file-name "Move file to: ")
                       (read-file-name "Move file to: "
                                       default-directory
                                       (expand-file-name (file-name-nondirectory (buffer-name))
                                                         default-directory)))))
  (when (file-exists-p new-location)
    (delete-file new-location))
  (let ((old-location (buffer-file-name)))
    (write-file new-location t)
    (when (and old-location
               (file-exists-p new-location))
      (delete-file old-location))))

(bind-key "C-x m" #'my/move-file)
#+end_src

** buffer file name to kill ring
https://github.com/baron42bba/.emacs.d/blob/master/bba.org#copy-buffer-file-name-to-kill-ring
#+begin_src emacs-lisp
(defun job/copy-buffer-file-name ()
  (interactive)
  (kill-new (buffer-file-name))
  (message ( format "stored '%s' in kill-ring" buffer-file-name)))
#+end_src

** smart comma
http://mbork.pl/2015-10-31_Smart_comma_and_other_punctuation
#+begin_src emacs-lisp
  (defun smart-self-insert-punctuation (count)
    "If COUNT=1 and the point is after a space, insert the relevant
  character before any spaces."
    (interactive "p")
    (if (and (= count 1)
             (eq (char-before) ?\s))
        (save-excursion
          (skip-chars-backward " ")
          (self-insert-command 1))
      (self-insert-command count)))

(eval-after-load 'tex '(define-key TeX-mode-map ","
                         'smart-self-insert-punctuation))
#+end_src
** job/kill-word-or-region
http://emacs.stackexchange.com/questions/28543/smartparens-strict-mode-c-w-kill-line-if-no-active-region/29927
#+begin_src emacs-lisp
(defun job/kill-word-or-region (&optional arg)
  "Kill active region or one word backward."
  (interactive "p")
  (if (use-region-p)
      (kill-region (region-beginning) (region-end))
    (if smartparens-strict-mode
        (sp-backward-kill-word arg)
      (backward-kill-word arg))))

(bind-key "C-w" 'job/kill-word-or-region)
#+end_src

** job/insert-enquote
#+begin_src emacs-lisp
  (defun job/insert-enquote ()
    (interactive)
    (insert "\\enquote{} "))

  (defun job/insert-enquote* ()
    (interactive)
    (insert "\\enquote*{} "))

  (defun job/enquote-wrapper ()
    (interactive)
    (if (not (eq last-command 'job/enquote-wrapper))
        (job/insert-enquote)
      (setq this-command nil)
      (forward-char 2)
      (delete-backward-char 11)
      (call-interactively 'job/insert-enquote*))
    (backward-char 2))

  (eval-after-load 'tex '(define-key TeX-mode-map "\"" 'job/enquote-wrapper))
#+end_src

** job/kill-line
#+begin_src emacs-lisp
(defun job/kill-line ()
  (interactive)
  (if (equal (point) (line-end-position))
      (kill-whole-line)
    (call-interactively 'kill-line)))

(bind-key "C-k" 'job/kill-line)
#+end_src


* shell-interaktion
** zettelkasten-gitstats
#+begin_src emacs-lisp
(defun zettelkasten-gitstats ()
   (interactive)
   (sc (concat "cd ~/Dropbox/db/zk &&"
               "gitstats .git gitstats &&"
               "firefox 'gitstats/index.html'")))
#+end_src

** write-channel
#+begin_src emacs-lisp
(defun job/write-channels ()
  (interactive)
  (sc "iwlist wlp3s0 scan > ~/.custom-temp/channels.txt")
  (find-file (expand-file-name (concat custom-temp "channels.txt"))))
#+end_src

** xrandr
*** xrandr-hydra
#+begin_src emacs-lisp
  (bind-key "C-c x" 'hydra-xrandr/body)
  (defhydra hydra-xrandr (:hint nil
                          :color red)
"
 ^Main^          ^VGA^                   ^HDMI^
-^-^-------------^---^-------------------^---^-----------------
 _a_: 1024x768   _vac_: 1024x768 clone   _hac_: 1024x768 clone
 ^ ^             _val_: 1024x768 left    _hal_: 1024x768 left
 _s_: 1366x768   _vsc_: 1366x768 clone   _hsc_: 1366x768 clone
 ^ ^             _vsl_: 1366x768 left    _hsl_: 1366x768 left
"
  ("r" xrandr-reset "reset")
  ("a" xrandr-main-1024x768)
  ("s" xrandr-main-1366x768)
  ("vac" xrandr-vga-1024x768-clone)
  ("val" xrandr-vga-1024x768-left)
  ("vsc" xrandr-vga-1366x768-clone)
  ("vsl" xrandr-vga-1366x768-left)
  ("hac" xrandr-hdmi-1024x768-clone)
  ("hal" xrandr-hdmi-1024x768-left)
  ("hsc" xrandr-hdmi-1366x768-clone)
  ("hsl" Xrandr-hdmi-1366x768-left)
  )

#+end_src

*** xrandr-reset
#+begin_src emacs-lisp
(defun xrandr-reset ()
  (interactive)
  (sc "xrandr --output eDP1 --mode 1366x768 --output DP1 --off --output HDMI1 --off --output VIRTUAL1 --off"))
#+end_src

*** xrandr-main-1024x768
#+begin_src emacs-lisp
(defun xrandr-main-1024x768 ()
  (interactive)
  (sc "xrandr --output eDP1 --mode 1024x768"))
#+end_src

*** xrandr-main-1366x768
#+begin_src emacs-lisp
(defun xrandr-main-1366x768 ()
  (interactive)
  (sc "xrandr --output eDP1 --mode 1366x768"))
#+end_src

*** xrandr-vga-1024x768-clone
#+begin_src emacs-lisp
(defun xrandr-vga-1024x768-clone ()
  (interactive)
  (sc "xrandr --output DP1 --mode 1024x768"))
#+end_src

*** xrandr-vga-1024x768-left
#+begin_src emacs-lisp
(defun xrandr-vga-1024x768-left ()
  (interactive)
  (sc "xrandr --output DP1 --mode 1024x768 --left-of eDP1"))
#+end_src

*** xrandr-vga-1366x768-clone
#+begin_src emacs-lisp
(defun xrandr-vga-1366x768-clone ()
  (interactive)
  (sc "xrandr --output DP1 --mode 1366x768"))
#+end_src

*** xrandr-vga-1366x768-left
#+begin_src emacs-lisp
(defun xrandr-vga-1366x768-left ()
  (interactive)
  (sc "xrandr --output DP1 --mode 1366x768 --left-of eDP1"))
#+end_src

*** xrandr-hdmi-1024x768-clone
#+begin_src emacs-lisp
(defun xrandr-hdmi-1024x768-clone ()
  (interactive)
  (sc "xrandr --output HDMI1 --mode 1024x768"))
#+end_src

*** xrandr-hdmi-1024x768-left
#+begin_src emacs-lisp
(defun xrandr-hdmi-1024x768-left ()
  (interactive)
  (sc "xrandr --output HDMI1 --mode 1024x768 --left-of eDP1"))
#+end_src

*** xrandr-hdmi-1366x768-clone
#+begin_src emacs-lisp
(defun xrandr-hdmi-1366x768-clone ()
  (interactive)
  (sc "xrandr --output HDMI1 --mode 1366x768"))
#+end_src

*** xrandr-hdmi-1366x768-left
#+begin_src emacs-lisp
(defun xrandr-hdmi-1366x768-left ()
  (interactive)
  (sc "xrandr --output HDMI1 --mode 1366x768 --left-of eDP1"))
#+end_src

** vpn
*** vpn-zedat
#+begin_src emacs-lisp
(defun job/vpn-zedat-shell ()
  (interactive)
  (shell)
  (rename-buffer "*vpn-shell*")
  (end-of-buffer)
  (insert "sudo openconnect -s /usr/share/vpnc-scripts/vpnc-script vpn.fu-berlin.de")
  (comint-send-input)
)
#+end_src
